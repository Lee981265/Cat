{"meta":{"title":"hojun","subtitle":null,"description":"好少年光芒万丈","author":"hojun","url":"https://lee.js.org/Cat"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-03-15T06:53:04.238Z","comments":false,"path":"about/index.html","permalink":"https://lee.js.org/Cat/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-03-15T06:53:04.242Z","comments":false,"path":"bangumi/index.html","permalink":"https://lee.js.org/Cat/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-03-15T06:53:04.252Z","comments":false,"path":"donate/index.html","permalink":"https://lee.js.org/Cat/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-03-15T06:53:04.246Z","comments":false,"path":"client/index.html","permalink":"https://lee.js.org/Cat/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-03-15T06:53:04.249Z","comments":true,"path":"comment/index.html","permalink":"https://lee.js.org/Cat/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-03-15T06:53:04.258Z","comments":true,"path":"links/index.html","permalink":"https://lee.js.org/Cat/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-03-15T06:53:04.255Z","comments":false,"path":"lab/index.html","permalink":"https://lee.js.org/Cat/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-03-15T06:53:04.265Z","comments":true,"path":"rss/index.html","permalink":"https://lee.js.org/Cat/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-03-15T06:53:04.262Z","comments":false,"path":"music/index.html","permalink":"https://lee.js.org/Cat/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-03-15T06:53:04.269Z","comments":true,"path":"tags/index.html","permalink":"https://lee.js.org/Cat/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-03-15T06:53:04.271Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://lee.js.org/Cat/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-03-15T06:53:04.275Z","comments":false,"path":"video/index.html","permalink":"https://lee.js.org/Cat/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"测试Mathjax支持","slug":"测试Mathjax支持","date":"2019-02-21T09:55:11.000Z","updated":"2019-03-15T06:53:04.198Z","comments":true,"path":"2019/02/21/测试Mathjax支持/","link":"","permalink":"https://lee.js.org/Cat/2019/02/21/测试Mathjax支持/","excerpt":"","text":"When $a \\ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"Canvas","slug":"Canvas","date":"2019-02-18T10:22:36.000Z","updated":"2019-03-15T08:42:21.328Z","comments":true,"path":"2019/02/18/Canvas/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/Canvas/","excerpt":"整理了一下canvas笔记。","text":"整理了一下canvas笔记。 canvas 是HTML5提供的一种新标签 是一个矩形区域的画布，可以用JavaScript在上面绘画，控制其每一个像素，本身不具备绘图功能。 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 使用： &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;你的浏览器不支持canvas，请升级浏览器&lt;/canvas&gt; canvas用途 游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。 可视化数据.数据图表话，比如:百度的echart banner广告：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。 canvas标签语法和属性 可以设置width和height属性，但是属性值单位必须是px，否则忽略，默认300*150px 不要用CSS控制它的宽和高,会造成图片拉伸， js重新设置canvas标签的宽高属性会让画布擦除所有的内容。 可以给canvas画布设置背景色 canvas坐标系canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大 Canvas API绘图上下文context上下文：工具包，是所有的绘制操作api的入口或者集合 canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。 context对象就是JavaScript操作Canvas的接口 使用getContext(‘2d’)来获取2D绘图上下文。 var canvas = document.querySelector(&#39;canvas&#39;); var ctx = canvas.getContext(&#39;2d&#39;); //注意：2d小写， 3d：webgl 绘制图形属性 lineWidth 设置线宽 strokeStyle 设置描边样式（默认黑色） fillStyle 设置填充样式（默认黑色） 方法 moveTo(x,y) 设置绘制路径的起点（移动画笔位置） lineTo(x,y) 画线 closePath() 闭合路径，必须闭合路径才能成功填充 beginPath() 开启一个新状态，基于之前的状态开启新的状态，新的状态会保持之前的设置 ctx.beginPath(); //开启新的状态后，当设置新的值时，只会作用于当前状态，不会影响之前的状态 ctx.lindeWidth = 2; ctx.strokeStyle = &#39;#ddd&#39;; rect(x,y,width,height) 绘制矩形路径x, y是矩形左上角坐标， width和height都是以像素计（下同） PS: rect方法只是规划了矩形的路径，并没有填充和描边 strokeRect(x,y,width,height) 绘制描边矩形 fillRect(x,y,width,height) 绘制填充矩形 stroke() 描边 fill() 填充，该方法会自动闭合路径 clearRect(x,y,width,height) 清除矩形区域， PS:重新设置canvas的宽/高也能达到清空的效果 arc(x,y,radius,startAngle,endAngle,counterclockwise) 画圆弧/画圆 x,y：圆心坐标。 radius：半径大小。 startAngle:绘制开始的角度（x轴为0度）。 endAngel:结束的角度，注意是弧度。 counterclockwise：是否是逆时针。true是逆时针，false：顺时针 弧度和角度的转换公式： rad = deg*Math.PI/180; 在Math提供的方法中sin、cos等都使用的弧度 **绘图步骤（5步）： 1、获得画布 var canvas = document.getElementById( &#39;cavsElem&#39; ); 2、获得canvas上下文 var ctx = canvas.getContext( &#39;2d&#39; ); 3、绘制路径 //设置绘制起点（移动画笔位置） ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(100,200); 4、设置样式 //设置线宽 ctx.lineWidth = 4; //设置描边样式（默认黑色） ctx.strokeStyle = &#39;red&#39;; //设置填充样式（默认黑色） ctx.fillStyle = &#39;#f60&#39;; 5、描边/填充 ctx.stroke(); ctx.fill(); PS：fill()方法会自动闭合路径 绘制字体（了解）属性 font 设置或返回文本内容的当前字体属性，语法与CSS相同 textAlign 设置或返回文本内容的当前对齐方式 start（默认）: 文本在指定的位置开始。 end : 文本在指定的位置结束。 center: 文本的中心被放置在指定的位置。 left : 文本左对齐。 right : 文本右对齐。 textBaseline 设置或返回在绘制文本时使用的当前文本基线 alphabetic ： 默认。文本基线是普通的字母基线。 top ： 文本基线是 em 方框的顶端。。 hanging ： 文本基线是悬挂基线。 middle ： 文本基线是 em 方框的正中。 ideographic： 文本基线是em基线。 bottom ： 文本基线是 em 方框的底端 方法 fillText(text,x,y) 填充字体 strokeText(text,x,y) 描边字体 measureText(text,x,y) 检测字体宽度,返回包含指定文本宽度的对象 text:文本 x,y：绘制文字起始坐标 绘制图片 基本绘制图片的方式 ctx.drawImage(img,x,y); 参数： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。 在画布上绘制图像，并规定图像的宽度和高度 ctx.drawImage(img,x,y,width,height); 参数： width 绘制图片的宽度， height：绘制图片的高度 如果指定宽高，最好成比例，不然图片会被拉伸 等比公式： height = 原高度*width/原宽度; 图片裁剪，并把裁剪完成后的那部分图片绘制到画布上 ctx.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数： sx,sy 裁剪的左上角坐标， swidth：裁剪图片的高度。 sheight:裁剪的高度 设置阴影（了解） shadowColor ： 设置或返回用于阴影的颜色 shadowBlur ： 设置或返回用于阴影的模糊级别,数值越高，模糊程度越大 （默认为0，不模糊） shadowOffsetX： 设置或返回阴影距形状的水平距离 shadowOffsetY： 设置或返回阴影距形状的垂直距离 示例： ctx.fillStyle = &#39;#fc0&#39;; ctx.shadowColor = &#39;#333&#39;; ctx.shadowBlur = 50; ctx.shadowOffsetX = 5; ctx.shadowOffsetY = 5; ctx.fillRect(100,100,100,100); 创建渐变样式（了解）线性渐变线性渐变是一个对象 语法：ctx.createLinearGradient(x0,y0,x1,y1);参数：x0,y0起始坐标，x1,y1结束坐标 addColorStop(stop,color) stop：介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置 color：颜色值 //创建线性渐变的对象， var grd=ctx.createLinearGradient(0,0,170,0); //添加一个渐变颜色， //参数1：0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。 //参数2：具体颜色 grd.addColorStop(0,&quot;black&quot;); //添加一个渐变颜色 grd.addColorStop(1,&quot;white&quot;); //关键点，把渐变设置到 填充的样式 ctx.fillStyle =grd; 径向渐变 ctx.createRadialGradient(x0,y0,r0,x1,y1,r1); x0: 渐变的开始圆的 x 坐标 y0: 渐变的开始圆的 y 坐标 r0: 开始圆的半径 x1: 渐变的结束圆的 x 坐标 y1: 渐变的结束圆的 y 坐标 r1: 结束圆的半径 var rlg = ctx.createRadialGradient(300,300,10,300,300,200); //添加一个渐变颜色 rlg.addColorStop(0, &#39;#ccc&#39;); rlg.addColorStop(.4, &#39;#efefef&#39;); rlg.addColorStop(1, &#39;#fff&#39;); //设置 填充样式为延续渐变的样式 ctx.fillStyle = rlg; ctx.fillRect(100, 100, 500, 500); 绘制背景图（了解）ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解 参数一：设置平铺背景的图片的DOM节点， 参数二：背景平铺的方式。 image ： 规定要使用的图片、画布或视频元素。 repeat ： 默认。该模式在水平和垂直方向重复。 repeat-x ： 该模式只在水平方向重复。 repeat-y ： 该模式只在垂直方向重复。 no-repeat： 该模式只显示一次（不重复）。 var ctx=c.getContext(&quot;2d&quot;); var img=document.getElementById(&quot;lamp&quot;); var pat=ctx.createPattern(img,&quot;repeat&quot;); ctx.rect(0,0,150,100); ctx.fillStyle=pat;// 把背景图设置给填充的样式 ctx.fill(); 画布变换 注意：画布变换仅仅是改变画布状态，不会影响之前画布上的内容 缩放scale(scaleWidth,scaleHeight) 方法缩放当前绘图，参数为0~1的值 位移画布translate(x,y) 方法重新映射画布上的 (0,0) 位置 旋转rotate(angle) 方法旋转当前的绘图，注意参数是弧度 绘制环境保存和还原 ctx.save() 保存当前环境的状态可以把当前绘制环境context保存到缓存中。 ctx.restore() 返回之前保存过的路径状态和属性获取最近通过save()方法缓存的context 保存base64编码图片 toDataURL(type, encoderOptions); type，设置输出的类型，比如 image/png image/jpeg等 encoderOptions：0-1之间的数字，用于标识输出图片的品质 PS:必须在服务器环境下使用 var canvas = document.getElementById(&quot;canvas&quot;); var dataURL = canvas.toDataURL(); var img = document.querySelector(&quot;img&quot;); img.src = canvas.toDataURL(&quot;image/png&quot;);//将画布的内容赋值给图片的src属性 贝塞尔曲线（了解）二次方曲线quadraticCurveTo(cpx,cpy,x,y) cpx： 贝塞尔控制点的 x 坐标 cpy： 贝塞尔控制点的 y 坐标 x ： 结束点的 x 坐标 y ： 结束点的 y 坐标 贝塞尔曲线bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点 cp1x： 第一个贝塞尔控制点的 x 坐标 cp1y： 第一个贝塞尔控制点的 y 坐标 cp2x： 第二个贝塞尔控制点的 x 坐标 cp2y： 第二个贝塞尔控制点的 y 坐标 x: 结束点的 x 坐标 y: 结束点的 y 坐标 Canvas应用 Echarts Highcharts","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://lee.js.org/Cat/tags/Canvas/"},{"name":"Html5","slug":"Html5","permalink":"https://lee.js.org/Cat/tags/Html5/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"这是示例文章15","slug":"这是示例文章15","date":"2019-02-18T05:02:43.000Z","updated":"2019-03-15T06:53:04.213Z","comments":true,"path":"2019/02/18/这是示例文章15/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章15/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章14","slug":"这是示例文章14","date":"2019-02-18T05:02:40.000Z","updated":"2019-03-15T06:53:04.211Z","comments":true,"path":"2019/02/18/这是示例文章14/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章14/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章13","slug":"这是示例文章13","date":"2019-02-18T05:02:36.000Z","updated":"2019-03-15T06:53:04.209Z","comments":true,"path":"2019/02/18/这是示例文章13/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章13/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章12","slug":"这是示例文章12","date":"2019-02-18T05:02:33.000Z","updated":"2019-03-15T06:53:04.206Z","comments":true,"path":"2019/02/18/这是示例文章12/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章12/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章11","slug":"这是示例文章11","date":"2019-02-18T05:02:30.000Z","updated":"2019-03-15T06:53:04.204Z","comments":true,"path":"2019/02/18/这是示例文章11/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章11/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章10","slug":"这是示例文章10","date":"2019-02-18T05:02:26.000Z","updated":"2019-03-15T06:53:04.202Z","comments":true,"path":"2019/02/18/这是示例文章10/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章10/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章9","slug":"这是示例文章9","date":"2019-02-18T05:02:22.000Z","updated":"2019-03-15T06:53:04.233Z","comments":true,"path":"2019/02/18/这是示例文章9/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章9/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章8","slug":"这是示例文章8","date":"2019-02-18T05:02:19.000Z","updated":"2019-03-15T06:53:04.230Z","comments":true,"path":"2019/02/18/这是示例文章8/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章8/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章7","slug":"这是示例文章7","date":"2019-02-18T05:02:17.000Z","updated":"2019-03-15T06:53:04.228Z","comments":true,"path":"2019/02/18/这是示例文章7/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章7/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章6","slug":"这是示例文章6","date":"2019-02-18T05:02:14.000Z","updated":"2019-03-15T06:53:04.224Z","comments":true,"path":"2019/02/18/这是示例文章6/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章6/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章5","slug":"这是示例文章5","date":"2019-02-18T05:02:11.000Z","updated":"2019-03-15T06:53:04.222Z","comments":true,"path":"2019/02/18/这是示例文章5/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章5/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章4","slug":"这是示例文章4","date":"2019-02-18T05:02:08.000Z","updated":"2019-03-15T06:53:04.220Z","comments":true,"path":"2019/02/18/这是示例文章4/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章4/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章3","slug":"这是示例文章3","date":"2019-02-18T05:02:05.000Z","updated":"2019-03-15T06:53:04.217Z","comments":true,"path":"2019/02/18/这是示例文章3/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章3/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章2","slug":"这是示例文章2","date":"2019-02-18T05:02:02.000Z","updated":"2019-03-15T06:53:04.215Z","comments":true,"path":"2019/02/18/这是示例文章2/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章2/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"这是示例文章1","slug":"这是示例文章1","date":"2019-02-18T05:01:59.000Z","updated":"2019-03-15T06:53:04.200Z","comments":true,"path":"2019/02/18/这是示例文章1/","link":"","permalink":"https://lee.js.org/Cat/2019/02/18/这是示例文章1/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"如何提升自我素养","slug":"如何提升自我素养","date":"2019-02-11T06:31:50.000Z","updated":"2019-03-11T08:46:36.440Z","comments":true,"path":"2019/02/11/如何提升自我素养/","link":"","permalink":"https://lee.js.org/Cat/2019/02/11/如何提升自我素养/","excerpt":"很多女孩都说我是一个直男！！！ 那么如何改变自己呢？ 情操 + 情商 = 完美 ？","text":"很多女孩都说我是一个直男！！！ 那么如何改变自己呢？ 情操 + 情商 = 完美 ？ 在我们的生活中，我们不但要让我们的物质世界获得满足，作为万物灵长的我们，还应该注重我们 内心世界的渴求，去获得我们内心世界的满足，去丰富我们的精神世界，让我们的内心世界不再是 一片荒芜的沙漠，去做一个有才情的人，那么，如何去 丰富我们的精神世界呢?如何去培养我们的情操呢？ 情操的培养热爱读书想要培养我们的情操，首先要热爱读书，所谓书中自有黄金屋，书中自有颜如玉，崇高的道德操守 来源于一代又一代人的积累，只有从书中汲取养分，我们才能不断的成长，才能够真正地培养和提 高我们的情操。 不断反思自己想要培养自己的情操，就要不断反思自己，只有不断反思自己，才能够不断的提高自己，同时在反 思自我中，我们也在提高我们的情操，让我们更加的完善，做更好的自己。 关爱他人所以情操，就是道德操守，要想培养情操，就应该从自身出发，推己及人，像关爱自己那样去关爱 他人，只有这样才能算是一个有情操的人，因此在生活中，我们应该更多地关爱别人。 宽广的胸襟有情操的人，他们有气度，有胸襟，不会因为他们的无意一句话而发怒，也不会因为别人无意的错 误而生气，他们懂的宽容别人。他们对自己严格要求，但他们对别人要求宽松，只有胸襟宽广的人 才能成为有情操的人。 谦虚有情操的人，他们不会整天夸夸其谈，不会整天吹嘘自己，也不会整天奉承别人，有情操的人懂的 谦虚，他们不会自满，他们愿意接受别人的批评，所以他们能都不断提高自身的素养和情操，所以 想要做有情操的人，一定要学会谦虚。 生活阅历丰富只有经过岁月洗礼的人，他们才能够不断丰富自己，不断提高自己，让自己变得更加优秀，同样也 只有这样才能培养自己的情操，培养情操是一个长期的过程，只有拥有丰富的生活阅历，慢慢地培 养，坚持不懈才能够做一个有情操的人。 高情商的培养生气的时候尽量不要说话人每当生气的时候，肾上腺素会大量分泌，情绪会不受控制。 和关系不好的陌生人生气时 和陌生人生气时会毫无顾忌的说一下难听的话甚至粗鄙之语，你讲的越多对方可能越生气，最糟糕的是发生肢体冲突 和亲人或者爱人生气时 有时候你或者是在气头上说话没有分寸，一旦说出令人伤心的话得不偿失，毕竟是我们所亲所爱，没有过不去的坎。 说话的语气一定要和气有时候一句话不同的人说出来的效果却完全不一样呢，为什么会这样呢？正所谓伸手不打笑脸人， 你有求于人或者冒犯别人时，笑着说话不仅可以掩饰自己的尴尬，还可以让对方不对你产生抵触， 但是，记住不要做舔狗。 说话要有底气吾之所爱，吾当勇敢去爱，不要表现的过于懦弱；但是不要满嘴跑火车，这样会适得其反。 说话要守诚信古人云：‘言必信，行必果。’，说过话就要办到，切勿失信于人。 得饶人处且饶人古人云：“人非圣贤，孰能无过，知错能改，善莫大焉。”，做人要大度，懂得宽容别人，这样别人 就会更加尊敬你，你的威望也会上升。 要多读书古人语：“多万卷书，行万里路。”，我们可以从书中学到很多知识不断充实自己，以史为鉴，换位 思考，时刻警醒自己。 不能自负，鄙视他人每个人诞生下来都有自己生活的权利。或许有些人诞生在王宫贵族，名门望族，有些人诞生在十恶 不赦的杀人犯家里，不能以歧视的目光看待他人。获取你会谄媚首富之子，蔑视乞丐之子，殊不知 三十年河东，三十年河西，莫欺少年穷！有钱人终究有一天会家道中落，没钱的人会终有一天有钱 又有优势。你嘲笑别人，殊不知虎落平阳被犬欺！ 切勿在背后妄论别人古人云：“君子坦荡荡，小人常戚戚。”，在背后嚼舌根是小人行径，你妄论的人在得知你的言语之 后，只会使你们的关系更加糟糕。 不要记仇古人云：“宰相肚里能撑船”，“海纳百川，有容乃大”，宽阔的胸怀和胸襟是一个高情操的人所必需 的优秀品质。 切勿以己之任，加之彼身古人云：“人无完人，金无赤足。”，或许你自己在某方面很优秀，但是别人不如你，你不能够按照 自己的标准要求别人。或许别人某些方面比你优秀呢，换位思考一下呢？是不是有一些强人所难？ 己所不欲勿施于人自己都做不到的不要强加与别人 尊老爱幼位卑未敢忘忧国每日三省吾身自我勉励，不可妄自菲薄，我能行！","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}],"tags":[{"name":"For Myself","slug":"For-Myself","permalink":"https://lee.js.org/Cat/tags/For-Myself/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}]},{"title":"hexo常用命令笔记","slug":"hexo常用命令笔记","date":"2019-01-29T10:18:54.000Z","updated":"2019-03-08T04:05:14.578Z","comments":true,"path":"2019/01/29/hexo常用命令笔记/","link":"","permalink":"https://lee.js.org/Cat/2019/01/29/hexo常用命令笔记/","excerpt":"重新整理了一下hexo命令","text":"重新整理了一下hexo命令 hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] &lt;title&gt; 模板 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold） hexo new photo “My Gallery” 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lee.js.org/Cat/tags/Hexo/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}]},{"title":"Java特性","slug":"Java特性","date":"2019-01-23T04:03:17.000Z","updated":"2019-03-08T04:05:13.713Z","comments":true,"path":"2019/01/23/Java特性/","link":"","permalink":"https://lee.js.org/Cat/2019/01/23/Java特性/","excerpt":"开始学习Java了","text":"开始学习Java了 主要特性Java语言是简单的：Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习 和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 Java语言是面向对象的：Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。 Java语言是分布式的：Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的：Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。 Java语言是安全的：Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。 Java语言是体系结构中立的：Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 Java语言是可移植的：这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。 Java语言是解释型的：如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 Java是高性能的：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。 Java语言是多线程的：在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。 Java语言是动态的：Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"},{"name":"Java","slug":"Essay/Java","permalink":"https://lee.js.org/Cat/categories/Essay/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lee.js.org/Cat/tags/Java/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"},{"name":"Java","slug":"Essay/Java","permalink":"https://lee.js.org/Cat/categories/Essay/Java/"}]},{"title":"Markdown教程","slug":"Markdown教程","date":"2019-01-15T10:22:37.000Z","updated":"2019-03-08T04:05:15.561Z","comments":true,"path":"2019/01/15/Markdown教程/","link":"","permalink":"https://lee.js.org/Cat/2019/01/15/Markdown教程/","excerpt":"想写博客记录自己学习的点点滴滴吗？点开这里 =&gt;传送门","text":"想写博客记录自己学习的点点滴滴吗？点开这里 =&gt;传送门 Guide这是一篇讲解如何正确使用 Markdown 的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。 引用文本：Markdown is a text formatting syntax inspired 语法指导普通内容这段内容展示了在内容里面一些小的格式，比如： 加粗 - **加粗** 倾斜 - *倾斜* 删除线 - ~~删除线~~ Code 标记 - Code 标记 超级链接 - [超级链接](https://github.com) username@gmail.com - [username@gmail.com](mailto:username@gmail.com) 表情符号 Emoji支持大部分标准的表情符号，可使用输入法直接输入 一些表情例子:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed::+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :anger: 效果如图所示： 大标题 - Heading 3你可以选择使用 H1 至 H6，使用 ##(N) 打头。 NOTE: 别忘了 # 后面需要有空格！ Heading 4Heading 5Heading 6图片![alt 文本](https://lee981265.github.io/img/Leebolg.png) ![alt 文本](https://lee981265.github.io/img/Leebolg.png &quot;图片 Title 值&quot;) 效果如图所示： 支持复制粘贴直接上传。 代码块普通*emphasize* **strong** _emphasize_ __strong__ var a = 1 语法高亮支持如果在 ` 后面跟随语言名称，可以有语法高亮的效果哦，比如: 演示 Go 代码高亮package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, 世界&quot;) } 演示 Java 高亮public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello World!&quot;); } } 效果如图所示： Tip: 语言名称支持下面这些: ruby, python, js, html, erb, css, coffee, bash, json, yml, xml … 有序、无序列表无序列表 Java Spring IoC AOP Go gofmt Wide Node.js Koa Express 有序列表 Node.js1.1. Express1.2. Koa1.3. Sails Go2.1. gofmt2.2. Wide Java3.1. Latke3.2. IDEA 表格如果需要展示数据什么的，可以选择使用表格。 header 1 header 3 cell 1 cell 2 cell 3 cell 4 cell 5 cell 6 隐藏细节SummaryDetails 段落留空白的换行，将会被自动转换成一个段落，会有一定的段落间距，便于阅读。 请注意后面 Markdown 源代码的换行留空情况。 数学公式$$a^2 + b^2 = \\color{red}c^2$$ 效果如图所示： 复选框command line initiate participate redeem refund doc ReadMe ReadMe_CN 流程图st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op 效果如图所示： 时序图张三-&gt;李四: 嘿，小四儿, 写博客了没? Note right of 李四: 李四愣了一下，说： 李四--&gt;张三: 忙得吐血，哪有时间写。 效果如图所示： 2019弹指间2018悄然溜走，我也在昨天渡过22岁生日。新的一年祝大家好运常来，在2019我决定开始学习python和java，也会在这里和大家分享一下我踩过的坑和笔记。2019加油！ :smirk_cat:）","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lee.js.org/Cat/tags/Markdown/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-03-15T06:53:04.195Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://lee.js.org/Cat/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"最近又一次接触到了web端全景，是在720yun上，发现有好多用户上传的全景照片。再也按捺不住那颗好奇的心，去探究了下720云是怎么实现web端全景展示的。 分析加载的资源我们使用f12开发者工具，查看分析找到了krp-player这个关键的js文件，并在js文件首部找到了它的原名”krpano”（稍微提一下：可能你还听说有其他插件或方式实现web全景:比如three.js，但那些都不是很成熟，存在大大小小的bug，而krpano比较成熟也是大部分全景网站所使用的，所以是收费的。）。于是搜索到了它的官网，并进行下载它的安装包（下载速度太慢可以搜索其百度网盘资源去下载） 安装krpano下载好后，双击安装到目录（自定义）。安装好后如下图 使用krpano使用教程可以参考krpano360的。准备一张或多张全景图：注意：要求的全景图长宽比为2:1直接将全景拖到需要生成类型的bat上（我这里是MAKE VTOUR (VR-OPT) droplet，也是教程所推荐的）然后krpano就好自动处理图片，并生成html网页文件。生成的文件和图片在同一目录，如我的图片在桌面，生成的文件也在桌面。这样子直接打开html文件还不能浏览全景图片，需要在服务器环境下访问才行（其他服务器环境也行）这里我们用krpano自带的server工具。双击它：可以看到服务开启的目录在krpano的安装目录下，我们可以把生成的文件复制过来访问：（这里我在安装目录下新建了一个文件夹）再打开之前server工具给的那个地址，进入到目录下，点击tour.html即可预览全景预览如下：发现它的水印是不是多的恐怖2333333，需要购买才能去除。或者…… 最后其实可以退一步，就用一些全景平台就行了，比如720yun。这篇文章仅是为了探究下全景实现，到此为止了大致了解了，完。","categories":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lee.js.org/Cat/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://lee.js.org/Cat/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lee.js.org/Cat/categories/技术/"}]},{"title":"Vue路由传参三种基本方式","slug":"Vue路由传参三种基本方式","date":"2018-12-11T11:56:26.000Z","updated":"2019-03-08T04:04:41.182Z","comments":true,"path":"2018/12/11/Vue路由传参三种基本方式/","link":"","permalink":"https://lee.js.org/Cat/2018/12/11/Vue路由传参三种基本方式/","excerpt":"Vue路由传参的三种基本方式","text":"Vue路由传参的三种基本方式 现有如下场景，点击父组件的li元素跳转到子组件中，并携带参数，便于子组件获取数据。父组件中： &lt;li v-for=&quot;article in articles&quot; @click=&quot;getDescribe(article.id)&quot;&gt; methods： case1getDescribe(id) { //直接调用$router.push 实现携带参数的跳转 this.$router.push({ path: `/describe/${id}`, }) case1需要对应路由配置如下： { path: &#39;/describe/:id&#39;, name: &#39;Describe&#39;, component: Describe } 很显然，需要在path中添加/:id来对应 $router.push 中path携带的参数。在子组件中可以使用来获取传递的参数值。 $route.params.id case2父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。 this.$router.push({ name: &#39;Describe&#39;, params: { id: id } }) 对应路由配置: 注意这里不能使用:/id来传递参数了，因为父组件中，已经使用params来携带参数了。 { path: &#39;/describe&#39;, name: &#39;Describe&#39;, component: Describe } 子组件中: 这样来获取参数 $route.params.id case3父组件：使用path来匹配路由，然后通过query来传递参数这种情况下 query传递的参数会显示在url后面?id=？ this.$router.push({ path: &#39;/describe&#39;, query: { id: id } }) 对应路由配置： { path: &#39;/describe&#39;, name: &#39;Describe&#39;, component: Describe } 对应子组件: 这样来获取参数 $route.query.id","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lee.js.org/Cat/tags/Vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://lee.js.org/Cat/tags/vue-router/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"Sql语句","slug":"Sql语句","date":"2018-10-16T02:46:06.000Z","updated":"2019-03-08T04:05:06.310Z","comments":true,"path":"2018/10/16/Sql语句/","link":"","permalink":"https://lee.js.org/Cat/2018/10/16/Sql语句/","excerpt":"Sql语句大全","text":"Sql语句大全 基础 说明：创建数据库 CREATE DATABASE database-name 说明：删除数据库 drop database dbname 说明：备份sql server— 创建 备份数据的 device USE master EXEC sp_addumpdevice &#39;disk&#39;, &#39;testBack&#39;, &#39;c:\\mssql7backup\\MyNwind_1.dat&#39; 开始 备份 BACKUP DATABASE pubs TO testBack 说明：创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..) 根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only 说明：删除新表 drop table tabname 说明：增加一个列 Alter table tabname add column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 说明：添加主键： Alter table tabname add primary key(col)说明：删除主键： Alter table tabname drop primary key(col) 说明：创建索引：create [unique] index idxname on tabname(col….)删除索引：drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 说明：创建视图：create view viewname as select statement删除视图：drop view viewname 说明：几个简单的基本的sql语句 选择：select from table1 where 范围*插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select from table1 where field1 like ’%value1%’* —like的语法很精妙，查资料!排序：select from table1 order by field1,field2 [desc]*总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table1 说明：几个高级查询运算词A： UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 B： EXCEPT 运算符 EXCEPT运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 C： INTERSECT 运算符 INTERSECT运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 说明：使用外连接A、left （outer） join：左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。SQL:select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c B：right （outer） join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 C：full/cross （outer） join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 12、分组:Group by: 一张表，一旦分组 完成后，查询后只能得到组相关的信息。 组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准) 在SQLServer中分组时：不能以 text,ntext,image 类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起； 13、对数据库进行操作： 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名 14.如何修改数据库的名称: sp_renamedb &#39;old_name&#39;, &#39;new_name&#39; 提升 说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用) 法一：select into b from a where 1&lt;&gt;1*（仅用于SQlServer）法二：select top 0 into b from a* 说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用) insert into b(a, b, c) select d,e,f from b; 说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用) insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件 例子： ..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\\data.mdb” &amp;”‘ where.. 说明：子查询(表名1：a 表名2：b) select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3) 说明：显示文章、提交人和最后回复时间 select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b 说明：外连接查询(表名1：a 表名2：b) select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c 说明：在线视图查询(表名1：a ) select * from (SELECT a,b,c FROM a) T where t.a &gt; 1; 说明：between 的用法,between 限制查询数据范围时包括了边界值,not between 不包括 select * from table1 where time between time1 and time2 select a,b,c, from table1 where a not between 数值1 and 数值2 说明：in 的使用方法 select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’) 说明：两张关联表，删除主表中已经在副表中没有的信息 delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 ) 说明：四表联查问题： select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where ..... 说明：日程安排提前五分钟提醒SQL: select * from 日程安排 where datediff(&#39;minute&#39;,f开始时间,getdate())&gt;5 说明：一条sql 语句搞定数据库分页 select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段 具体实现：关于数据库分页： declare @start int,@end int @sql nvarchar(600) set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’ exec sp_executesql @sql 注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引） 说明：前10条记录 select top 10 * form table1 where 范围 说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.) select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b) 说明：包括所有在 TableA中但不在 TableB和TableC中的行并消除所有重复行而派生出一个结果表 (select a from tableA ) except (select a from tableB) except (select a from tableC) 说明：随机取出10条数据 select top 10 * from tablename order by newid() 说明：随机选择记录 select newid() 说明：删除重复记录1. delete from tablename where id not in (select max(id) from tablename group by col1,col2,...) 2. select distinct * into temp from tablename delete from tablename insert into tablename select * from temp 评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作 例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段alter table tablename 添加一个自增列 add column_b int identity(1,1) delete from tablename where column_b not in( select max(column_b) from tablename group by column1,column2,...) alter table tablename drop column column_b 说明：列出数据库里所有的表名 select name from sysobjects where type=&#39;U&#39; // U代表用户 说明：列出表里的所有的列名 select name from syscolumns where id=object_id(&#39;TableName&#39;) 说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。 select type,sum(case vender when &#39;A&#39; then pcs else 0 end),sum(case vender when &#39;C&#39; then pcs else 0 end),sum(case vender when &#39;B&#39; then pcs else 0 end) FROM tablename group by type 显示结果： type vender pcs 电脑 A 1 电脑 A 1 光盘 B 2 光盘 A 2 手机 B 3 手机 C 3 说明：初始化表table1 TRUNCATE TABLE table1 说明：选择从10到15的记录 select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc 技巧 1=1，1=2的使用，在SQL语句组合时用的较多 “where 1=1” 是表示选择全部 “where 1=2”全部不选， 如： if @strWhere !=&#39;&#39; begin set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;] where &#39; + @strWhere end else begin set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;]&#39; end 我们可以直接写成 错误！未找到目录项。 set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;] where 1=1 安定 &#39;+ @strWhere 2、收缩数据库 重建索引 DBCC REINDEXDBCC INDEXDEFRAG 收缩数据和日志 DBCC SHRINKDBDBCC SHRINKFILE 压缩数据库 dbcc shrinkdatabase(dbname) 转移数据库给新用户以已存在用户权限 exec sp_change_users_login ‘update_one’,’newname’,’oldname’go 检查备份集 RESTORE VERIFYONLY from disk=&#39;E:\\dvbbs.bak&#39; 修复数据库 ALTER DATABASE [dvbbs] SET SINGLE_USER GO DBCC CHECKDB(&#39;dvbbs&#39;,repair_allow_data_loss) WITH TABLOCK GO ALTER DATABASE [dvbbs] SET MULTI_USER GO 日志清除 SET NOCOUNT ON DECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INT USE tablename -- 要操作的数据库名 SELECT @LogicalFileName = &#39;tablename_log&#39;, -- 日志文件名 @MaxMinutes = 10, -- Limit on time allowed to wrap log. @NewSize = 1 -- 你想设定的日志文件的大小(M) Setup / initialize DECLARE @OriginalSize int SELECT @OriginalSize = size FROM sysfiles WHERE name = @LogicalFileName SELECT &#39;Original Size of &#39; + db_name() + &#39; LOG is &#39; + CONVERT(VARCHAR(30),@OriginalSize) + &#39; 8K pages or &#39; + CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + &#39;MB&#39; FROM sysfiles WHERE name = @LogicalFileName CREATE TABLE DummyTrans (DummyColumn char (8000) not null) DECLARE @Counter INT, @StartTime DATETIME, @TruncLog VARCHAR(255) SELECT @StartTime = GETDATE(), @TruncLog = &#39;BACKUP LOG &#39; + db_name() + &#39; WITH TRUNCATE_ONLY&#39; DBCC SHRINKFILE (@LogicalFileName, @NewSize) EXEC (@TruncLog) -- Wrap the log if necessary. WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName) AND (@OriginalSize * 8 /1024) &gt; @NewSize BEGIN -- Outer loop. SELECT @Counter = 0 WHILE ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000)) BEGIN -- update INSERT DummyTrans VALUES (&#39;Fill Log&#39;) DELETE DummyTrans SELECT @Counter = @Counter + 1 END EXEC (@TruncLog) END SELECT &#39;Final Size of &#39; + db_name() + &#39; LOG is &#39; + CONVERT(VARCHAR(30),size) + &#39; 8K pages or &#39; + CONVERT(VARCHAR(30),(size*8/1024)) + &#39;MB&#39; FROM sysfiles WHERE name = @LogicalFileName DROP TABLE DummyTrans SET NOCOUNT OFF 说明：更改某个表 exec sp_changeobjectowner &#39;tablename&#39;,&#39;dbo&#39; 存储更改全部表 CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch @OldOwner as NVARCHAR(128), @NewOwner as NVARCHAR(128) AS DECLARE @Name as NVARCHAR(128) DECLARE @Owner as NVARCHAR(128) DECLARE @OwnerName as NVARCHAR(128) DECLARE curObject CURSOR FOR select &#39;Name&#39; = name, &#39;Owner&#39; = user_name(uid) from sysobjects where user_name(uid)=@OldOwner order by name OPEN curObject FETCH NEXT FROM curObject INTO @Name, @Owner WHILE(@@FETCH_STATUS=0) BEGIN if @Owner=@OldOwner begin set @OwnerName = @OldOwner + &#39;.&#39; + rtrim(@Name) exec sp_changeobjectowner @OwnerName, @NewOwner end -- select @name,@NewOwner,@OldOwner FETCH NEXT FROM curObject INTO @Name, @Owner END close curObject deallocate curObject GO SQL SERVER中直接循环写入数据 declare @i int set @i=1 while @i&lt;30 begin insert into test (userid) values(@i) set @i=@i+1 end 案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格: Name score Zhangshan 80 Lishi 59 Wangwu 50 Songquan 69 while((select min(score) from tb_table)&lt;60) begin update tb_table set score =score*1.01 where score&lt;60 if (select min(score) from tb_table)&gt;60 break else continue end 数据开发-经典 按姓氏笔画排序: Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多 数据库加密: select encrypt(&#39;原始密码&#39;) select pwdencrypt(&#39;原始密码&#39;) select pwdcompare(&#39;原始密码&#39;,&#39;加密后密码&#39;) = 1--相同；否则不相同 encrypt(&#39;原始密码&#39;) select pwdencrypt(&#39;原始密码&#39;) select pwdcompare(&#39;原始密码&#39;,&#39;加密后密码&#39;) = 1--相同；否则不相同 取回表中字段: declare @list varchar(1000), @sql nvarchar(1000) select @list=@list+&#39;,&#39;+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name=&#39;表A&#39; set @sql=&#39;select &#39;+right(@list,len(@list)-1)+&#39; from 表A&#39; exec (@sql) 4.查看硬盘分区: EXEC master..xp_fixeddrives 比较A,B表是否相等: if (select checksum_agg(binary_checksum(*)) from A) = (select checksum_agg(binary_checksum(*)) from B) print &#39;相等&#39; else print &#39;不相等&#39; 杀掉所有的事件探察器进程: DECLARE hcforeach CURSOR GLOBAL FOR SELECT &#39;kill &#39;+RTRIM(spid) FROM master.dbo.sysprocesses WHERE program_name IN(&#39;SQL profiler&#39;,N&#39;SQL 事件探查器&#39;) EXEC sp_msforeach_worker &#39;?&#39; 记录搜索: 开头到N条记录 Select Top N * From 表 N到M条记录(要有主索引ID) Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc N到结尾记录 Select Top N * From 表 Order by ID Desc 案例例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。 select top 10 recid from A where recid not in(select top 30 recid from A) 分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。 解决方案 用order by select top 30 recid from A order by ricid 如果该字段不是自增长，就会出现问题 在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1 例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。 set @s = &#39;select top 1 * from T where pid not in (select top &#39; + str(@count-1) + &#39; pid from T)&#39; print @s exec sp_executesql @s 获取当前数据库中的所有用户表 select Name from sysobjects where xtype=&#39;u&#39; and status&gt;=0 获取某一个表的所有字段`sqlselect name from syscolumns where id=object_id(‘表名’) select name from syscolumns where id in (select id from sysobjects where type = ‘u’ and name = ‘表名’) 两种方式的效果相同 11. 查看与某一个表相关的视图、存储过程、函数 ```sql select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like &#39;%表名%&#39; 查看当前数据库中所有存储过程 select name as 存储过程名称 from sysobjects where xtype=&#39;P&#39; 查询用户创建的所有数据库 select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name=&#39;sa&#39;) 或者 select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01 查询某一个表的字段和数据类型 select column_name,data_type from information_schema.columns where table_name = &#39;表名&#39; 不同服务器数据库之间的数据操作 创建链接服务器 exec sp_addlinkedserver &#39;ITSV &#39;, &#39; &#39;, &#39;SQLOLEDB &#39;, &#39;远程服务器名或ip地址 &#39; exec sp_addlinkedsrvlogin &#39;ITSV &#39;, &#39;false &#39;,null, &#39;用户名 &#39;, &#39;密码 &#39; 查询示例 select * from ITSV.数据库名.dbo.表名 导入示例 select * into 表 from ITSV.数据库名.dbo.表名 以后不再使用时删除链接服务器 exec sp_dropserver &#39;ITSV &#39;, &#39;droplogins &#39; 连接远程/局域网数据(openrowset/openquery/opendatasource) openrowset 查询示例 select * from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名) 生成本地表 select * into 表 from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名) 2. 把本地表导入远程表 ```sql insert openrowset( &#39;SQLOLEDB &#39;, &#39;sql服务器名 &#39;; &#39;用户名 &#39;; &#39;密码 &#39;,数据库名.dbo.表名) select *from 本地表 ``` 3. 更新本地表 ```sql update b set b.列A=a.列A from openrowset( &#39;SQLOLEDB &#39;, &#39;sql服务器名 &#39;; &#39;用户名 &#39;; &#39;密码 &#39;,数据库名.dbo.表名)as a inner join 本地表 b on a.column1=b.column1 ``` 4. openquery用法需要创建一个连接 &gt;首先创建一个连接创建链接服务器 exec sp_addlinkedserver &#39;ITSV &#39;, &#39; &#39;, &#39;SQLOLEDB &#39;, &#39;远程服务器名或ip地址 &#39; 5. 查询 ```sql select * FROM openquery(ITSV, &#39;SELECT * FROM 数据库.dbo.表名 &#39;) ``` 6. 把本地表导入远程表 ```sql insert openquery(ITSV, &#39;SELECT * FROM 数据库.dbo.表名 &#39;) select * from 本地表 ``` 7. 更新本地表 ```sql update b set b.列B=a.列B FROM openquery(ITSV, &#39;SELECT * FROM 数据库.dbo.表名 &#39;) as a inner join 本地表 b on a.列A=b.列A ``` 8. opendatasource/openrowset ```sql SELECT * FROM opendatasource( &#39;SQLOLEDB &#39;, &#39;Data Source=ip/ServerName;User ID=登陆名;Password=密码 &#39; ).test.dbo.roy_ta ``` 9. 把本地表导入远程表 ```sql insert opendatasource( &#39;SQLOLEDB &#39;, &#39;Data Source=ip/ServerName;User ID=登陆名;Password=密码 &#39;).数据库.dbo.表名 select * from 本地表 SQL Server基本函数 SQL Server基本函数 ``` 字符串函数 长度与分析用 datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格 substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度 right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反 isnull( check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类 Sp_addtype自定義數據類型例如. EXEC sp_addtype birthday, datetime, ‘NULL’ set nocount {on|off}使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。 SET NOCOUNT为 OFF 时，返回计数 常识 在SQL查询中：from后最多可以跟多少张表或视图：256在SQL语句中出现 Order by,查询时，先排序，后取在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。 SQLServer2000同步复制技术实现步骤 一、 预备工作 1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户--管理工具--计算机管理--用户和组--右键用户--新建用户--建立一个隶属于administrator组的登陆windows的用户（SynUser）2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作: 我的电脑--D:\\ 新建一个目录,名为: PUB --右键这个新建的目录--属性--共享--选择&quot;共享该文件夹&quot;--通过&quot;权限&quot;按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限 --确定3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置) 开始--程序--管理工具--服务 --右键SQLSERVERAGENT--属性--登陆--选择&quot;此账户&quot;--输入或者选择第一步中创建的windows登录用户名（SynUser）--&quot;密码&quot;中输入该用户的密码4.设置SQL Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置) 企业管理器 --右键SQL实例--属性--安全性--身份验证--选择&quot;SQL Server 和 Windows&quot;--确定5.在发布服务器和订阅服务器上互相注册 企业管理器 --右键SQL Server组--新建SQL Server注册...--下一步--可用的服务器中,输入你要注册的远程服务器名 --添加--下一步--连接使用,选择第二个&quot;SQL Server身份验证&quot;--下一步--输入用户名和密码（SynUser）--下一步--选择SQL Server组,也可以创建一个新组--下一步--完成6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到） (在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP) 开始--程序--Microsoft SQL Server--客户端网络实用工具 --别名--添加--网络库选择&quot;tcp/ip&quot;--服务器别名输入SQL服务器名--连接参数--服务器名称中输入SQL服务器ip地址--如果你修改了SQL的端口,取消选择&quot;动态决定端口&quot;,并输入对应的端口号 二、 正式配置 1、配置发布服务器 打开企业管理器，在发布服务器（B、C、D）上执行以下步骤: (1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己）(3) [下一步] 设置快照文件夹 采用默认\\\\servername\\Pub (4) [下一步] 自定义配置 可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置 否,使用下列默认设置（推荐） (5) [下一步] 设置分发数据库名称和位置 采用默认值(6) [下一步] 启用发布服务器 选择作为发布的服务器(7) [下一步] 选择需要发布的数据库和发布类型(8) [下一步] 选择注册订阅服务器(9) [下一步] 完成配置2、创建出版物 发布服务器B、C、D上 (1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令(2)选择要创建出版物的数据库，然后单击[创建发布](3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。 但是在这里我们选择运行&quot;SQL SERVER 2000&quot;的数据库服务器 (5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表 注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表 (6)选择发布名称和描述(7)自定义发布属性 向导提供的选择: 是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性 否 根据指定方式创建发布 （建议采用自定义的方式） (8)[下一步] 选择筛选发布的方式(9)[下一步] 可以选择是否允许匿名订阅1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器 方法: [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加 否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅 如果仍然需要匿名订阅则用以下解决办法 [企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示(10)[下一步] 设置快照 代理程序调度(11)[下一步] 完成配置 当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库 有数据 srv1.库名..author有字段:id,name,phone, srv2.库名..author有字段:id,name,telphone,adress 要求： srv1.库名..author增加记录则srv1.库名..author记录增加srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新 -- --大致的处理步骤--1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步exec sp_addlinkedserver &#39;srv2&#39;,&#39;&#39;,&#39;SQLOLEDB&#39;,&#39;srv2的sql实例名或ip&#39; exec sp_addlinkedsrvlogin &#39;srv2&#39;,&#39;false&#39;,null,&#39;用户名&#39;,&#39;密码&#39; go --2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动 。我的电脑--控制面板--管理工具--服务--右键 Distributed Transaction Coordinator--属性--启动--并将启动类型设置为自动启动 go --然后创建一个作业定时调用上面的同步处理存储过程就行了 企业管理器 --管理--SQL Server代理--右键作业--新建作业--&quot;常规&quot;项中输入作业名称--&quot;步骤&quot;项--新建--&quot;步骤名&quot;中输入步骤名--&quot;类型&quot;中选择&quot;Transact-SQL 脚本(TSQL)&quot; --&quot;数据库&quot;选择执行命令的数据库--&quot;命令&quot;中输入要执行的语句: exec p_process --确定--&quot;调度&quot;项--新建调度--&quot;名称&quot;中输入调度名称--&quot;调度类型&quot;中选择你的作业执行安排--如果选择&quot;反复出现&quot; --点&quot;更改&quot;来设置你的时间安排 然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行 设置方法: 我的电脑--控制面板--管理工具--服务--右键 SQLSERVERAGENT--属性--启动类型--选择&quot;自动启动&quot;--确定. --3.实现同步处理的方法2,定时同步 --在srv1中创建如下的同步处理存储过程 ```sql create proc p_process as –更新修改过的数据 update b set name=i.name,telphone=i.telphone from srv2.库名.dbo.author b,author i where b.id=i.id and (b.name &lt;&gt; i.name or b.telphone &lt;&gt; i.telphone) –插入新增的数据insert srv2.库名.dbo.author(id,name,telphone) select id,name,telphone from author i where not exists( select * from srv2.库名.dbo.author where id=i.id) –删除已经删除的数据(如果需要的话) delete b from srv2.库名.dbo.author b where not exists( select * from author where id=b.id) go `","categories":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"https://lee.js.org/Cat/tags/Sql/"}],"keywords":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}]},{"title":"Python3基础","slug":"Python3基础","date":"2018-10-02T18:15:41.000Z","updated":"2019-03-08T04:05:08.719Z","comments":true,"path":"2018/10/03/Python3基础/","link":"","permalink":"https://lee.js.org/Cat/2018/10/03/Python3基础/","excerpt":"前端萌新学习Python之旅，跟随廖雪峰大神的步伐，一天一天的进步！","text":"前端萌新学习Python之旅，跟随廖雪峰大神的步伐，一天一天的进步！ git bash 构建python 环境 python git bush开启python winpty python - python -i - python bash.bashrc追加 alias python=’winpty python ‘ 输出name = input(&#39;please your name:&#39;) print(&#39;hello&#39;,name) 条件语句(惯例缩进四个空格)#缩进4个空格 a = 100 if a&gt;=0: print(a) else: print(-a) #不缩进也可 b = 200 if b&gt;=0:print(b) else:print(-b) 数据类型类型 类型 表现形式 注意 整数 100 浮点数 3,14 字符串 ‘abc’，”xyz” I’m ok 字符串转义注意：对于字符串中含有特殊字符的这一点和正则有点像这时候我们要用到转译字符 ‘\\‘或者使用双引号在外=&gt;”I’m OK” &#39;I\\&#39;m \\&quot;OK\\&quot;!&#39; #I&#39;m &quot;OK&quot; 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\ print(&#39;I\\&#39;m ok.&#39;) #I&#39;m ok. print(&#39;I\\&#39;m learning\\nPython.&#39;) #I&#39;m learning #Python. print(&#39;\\\\\\n\\\\&#39;) #\\ #\\ 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义 print(r&#39;\\\\有一个姑娘，\\她有些任性\\\\&#39;) #这里需要注意无论在哪里使用转译符号‘\\’,在字符串开头可以随便用；在字符串末尾不能出现一个单独的‘\\’,否则会报错 &gt;SyntaxError: EOL while scanning string literal print(r&#39;\\\\有一个姑娘，\\她有些任性\\&#39;) 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容 print(&#39;&#39;&#39; line1 line2 line3 &#39;&#39;&#39;) # #line1 #line2 #line3 # print(&#39;&#39;&#39;123 123 123 &#39;&#39;&#39;) #123 123 #123 # print(r&#39;&#39;&#39;hello,\\n world&#39;&#39;&#39;) #hello,\\n #world 归纳 符号 作用 注意 \\ 转义特殊字符 字符串末尾至少加2个 \\n 表示换行 在r’’或r’’’ ‘’’内无效 \\t 表示制表符 在r’’或r’’’ ‘’’内无效 r’’ 不转义引号里面的内容 ‘’’ ‘’’ 多次换行 书写时多敲几次换行 变量与布尔值 注意：在python环境中布尔值开头必须大写 布尔值的运算符 运算符有 and,or,not`py #and True and TrueTrue Fslse and FalseFalse True and FalseFalse #or True or TrueTrue False or FalseFalse True or FalseTrue not not TrueFalse not FalseTrue not 1&lt;8True #条件语句if a&gt;=100 print(‘大于等于’)else: print(‘小于’) ### 空值 &gt;空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值 ### 变量 &gt;变量规则：变量名必须是大小写英文、数字和_的组合，且不能用数字开头，变量的声明不用像js那样加var ,let,const ```py a = 100 b = &#39;lee&#39; c = True 变量是可以赋值的，且可以多次赋值，后面的覆盖前面的赋值 a = 10086 a = &#39;你好&#39; print(a) 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： int a = 123; // a是整数类型变量 a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 常量 所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量 PI = 3.14159265359 除法 运算符 / , // , % &gt;&gt;&gt;10/3 3.33333333335 #结果为浮点数 &gt;&gt;&gt;9/3 3.0 #结果为浮点数 &gt;&gt;&gt;10//3 3 #结果向下取整 &gt;&gt;&gt;10%3 1 #结果取余","categories":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lee.js.org/Cat/tags/Python/"},{"name":"Python3","slug":"Python3","permalink":"https://lee.js.org/Cat/tags/Python3/"},{"name":"Note","slug":"Note","permalink":"https://lee.js.org/Cat/tags/Note/"}],"keywords":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}]},{"title":"ECMAScript5(ES5)","slug":"ES5","date":"2018-09-27T01:56:59.000Z","updated":"2019-03-08T04:05:23.548Z","comments":true,"path":"2018/09/27/ES5/","link":"","permalink":"https://lee.js.org/Cat/2018/09/27/ES5/","excerpt":"ECMAScript (or ES) is a trademarked scripting-language specification standardized by Ecma International in ECMA-262 and ISO/IEC 16262. It was created to standardize JavaScript, so as to foster multiple independent implementations.","text":"ECMAScript (or ES) is a trademarked scripting-language specification standardized by Ecma International in ECMA-262 and ISO/IEC 16262. It was created to standardize JavaScript, so as to foster multiple independent implementations. JavaScript has remained the best-known implementation of ECMAScript since the standard was first published, with other well-known implementations including JScript and ActionScript. ECMAScript is commonly used for client-side scripting on the World Wide Web, and it is increasingly being used for writing server applications and services using Node.js. Array新增方法静态方法 Array.isArray() 判断是否为数组 索引方法 区别就是一个从前往后找，一个从后往前找 indexOf/lastIndexOf(keyword [,startIndex]) keyword: 要查找的项， startIndex：查找起点位置的索引，该参数可选 方法返回keyword所在数组中的索引值，如果数组不存在keyword，则返回-1 迭代方法 forEach(fn) 遍历方法，for循环没有太大差别，比for循环方便 map(fn) 返回每次函数调用的结果组成的数组 filter(fn) 得到执行fn后返回true时对应的数组元素，利用这个方法可对数组元素进行过滤筛选 every(fn) 如果该函数对每一项都返回 true，则返回true some(fn) 如果该函数对任何一项返回 true，则返回true 以上方法都对数组中的每一项运行给定函数fn,，函数中有三个形参分别为 item：数组中的每一项, index：遍历过程中对应的索引值, array：对数组的引用 归并方法 这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。 reduce(fn,initVal) reduceRight(fn,initVal) fn(prev,cur,index,array): fn是每一项调用的函数，函数接受4个参数分别是 prev：前一次返回值， cur：当前值， index：索引值， array：当前数组，函数需要返回一个值，这个值会在下一次迭代中作为prev的值 initVal: 迭代初始值（可选），如果缺省，prev的值为数组第一项","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"https://lee.js.org/Cat/tags/ES5/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"ES6语法简介","slug":"ES6语法简介","date":"2018-09-19T03:29:46.000Z","updated":"2019-03-08T04:05:23.026Z","comments":true,"path":"2018/09/19/ES6语法简介/","link":"","permalink":"https://lee.js.org/Cat/2018/09/19/ES6语法简介/","excerpt":"ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。","text":"ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。 ES6变量声明 let:代码块内的变量声明 变量声明不会提升 块级作用域 let不允许相同作用域内多次声明同一变量 const:常量声明 声明后无法修改值 块级作用域 const不允许相同作用域内多次声明同一变量 解构赋值ES6允许我们对数组和对象中提取值，对变量进行赋值，这被叫做“解构” 数组： 1. var [a,b,c] = [1,2,3] //a=1,b=2,c=3 2. var [a,[[b],c]] = [10,[[20],30]] //a=10,b=20,c=30 3. var [a,...b] = [1,2,3,4] //a=1,b=[2,3,4];...表示剩余参数 对象： var {a,b}={a:’html’,b:’css’} 变量必须与对象属性名相同，否则为undefined 如果变量名与属性名不相同，则必须写成以下格式才能取到值 var {a:test} ={a:&#39;html&#39;,b:&#39;css&#39;} //test=&gt;html 解构失败： var [a]=[],[b]=1,[c]=&#39;jiegou&#39;,[d]=false //a,b,c,d都得到undefined 指定默认值： var [a=true]=[] var {a=10} = {} &gt; 解构同样适用于let和const &gt; PS:解构只能用于数组和对象，如果解构不成功，变量会返回undefined，但如果对undefined和null解构则会报错 解构用途 交换变量值 var [x,y] = [y,x]; 函数返回多个值 function example(){ return [1,2,3] } //接收 var [x,y,z] = example(); 定义函数形参（重点） 函数的参数定义方式, 不用再考虑参数的顺序 function test({x,y,z}){} //传参 test({x:10,y:20,z:30}) //参数可以设置默认值 fuction test({x=10,y=20,z}){} ` 字符串扩展字符串方法 includes 判断是否包含某个字符，返回布尔值 startsWith/endsWith 是否以某一字符开头/结尾 let str=&#39;google&#39;; str.startsWith(&#39;g&#39;); //true str.endsWith(&#39;le&#39;); //true ` repeat(n) 得到字符串重复n次后的结果，n可以为小数，但不能为负数 &#39;laoxie&#39;.repeat(2);//laoxielaoxie 字符串模板, 使用反引号`表示(重点)你可以通过一种更加美观、更加方便的方式向字符串中插入变量 格式：${变量|函数}， 你好，我的名字叫${username},接下来是我的自我介绍：${introduce()} 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 数组扩展遍历 for..of var arr = [10,12,18,30] for (var value of arr) { console.log(value); } 这是最简洁、最直接的遍历数组元素的语法 这个方法避开了for-in循环的所有缺陷&gt; for…of跟for-in的区别很明显，就是直接取值，而不再取下标了 与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不支持普通对象 for-of循环也可以遍历其它的集合 DOM节点 字符串 Set/Map集合 对象扩展 Object.assign(obj1,obj2,…objN); 合并对象 Object.assign({a:1},{b:2},{b:4,c:3}); //{a:1,b:4,c:3} 只支持浅拷贝（对于引用类型，只拷贝引用） 忽略不可枚举属性 简写 ES6允许在对象之中直接写变量，如`js //@属性简写 var myName = ‘laoxie’; var obj = {myName};//属性名为变量名, 属性值为变量的值 //等效于 var obj = {myName:’laoxie’} //使用变量值作为属性名 var obj = { [myName]:18 } //等效于 var obj = {laoxie:18} //@方法简写 var obj = { coding(){ } } //等效于 var obj = { coding:function(){ } } ``` 箭头函数=&gt;（重点）格式：标识符=&gt;表达式 省略了function、return关键字和大括号。 参数与返回值 零个参数用 () 表示 //传统写法 var sum = function(){ return 10 + 10; } //es6箭头函数 var sum = () =&gt; 10+10; 函数只有一个参数（可省略括号） //传统函数写法 var test = function(x){ return x+2; } //使用箭头函数 var test = x=&gt;x+2; 多个参数 // ES5 var total = values.reduce(function (a, b) { return a + b; }, 0); // ES6 var total = values.reduce((a, b) =&gt; a + b, 0); 函数中包含多行代码时用代码块括起来 ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始`js // ES5 $(“#confetti-btn”).click(function (event) { playTrumpet(); fireConfettiCannon(); }); // ES6 $(“#confetti-btn”).click(event =&gt; { playTrumpet(); fireConfettiCannon(); }); * 使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回 * 当使用箭头函数返回一个普通对象时，需要将对象包裹在小括号里 ```js //传统写法 var createPerson = function(){ return {name:&#39;laoxie&#39;,age:18} } // ES6 var createPerson = ()=&gt;{name:&#39;laoxie&#39;,age:18}; // 这样写会报Bug！ var createPerson = ()=&gt;({name:&#39;laoxie&#39;,age:18}); 默认参数。 var func1 = (x = 1, y = 2) =&gt; x + y; func1(); // 得到 3 剩余参数 var func2 = (x, ...args) =&gt; { console.log(args) }; func2(1,2,3); // 输出 [2, 3] 箭头函数中的this值箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域 Symbol数据类型ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，一旦创建后就不可更改。 // 没有参数的情况 var s1 = Symbol(); var s2 = Symbol(); s1 === s2 // false Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了标识和区分，对调式非常有用 // 有参数的情况 var s1 = Symbol(&quot;foo&quot;); var s2 = Symbol(&quot;foo&quot;); s1 === s2 // false Symbol值不能与其他类型的值进行运算 用途 给对象创建私有属性 var mySymbol = Symbol(); // 第一种写法 var a = {}; a[mySymbol] = &#39;Nani&#39;; // 第二种写法（注意加方括号，否则回被当作普通属性） var a = { [mySymbol]: &#39;Nani&#39; }; // 以上写法都得到同样结果 a[mySymbol] // &quot;Nani&quot; 常用方法 Symbol.for() 有时我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点，首先在全局中搜索已登记的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值&gt; 直接用Symbol()方法创建的Symbol值不会被登记let one = Symbol(&quot;laoxie&quot;); let two = Symbol.for(&quot;laoxie&quot;); //由于创建了两个Symbol值，所以他们不相等 console.log(one===two);//false Symbol.keyFor() 获取被登记的Symbol值&gt; 直接使用Symbo()创建的Symbol值的键不会被登记，所以也就获取不到 Map集合Map集合,即映射 设置 let map = new Map(); map.set(&quot;S0&quot;, &quot;张三&quot;); map.set(&quot;S1&quot;, &quot;李四&quot;); map.set(&quot;S2&quot;, &quot;王五&quot;); 获取 map.get(&quot;s2&quot;); //王五 循环遍历，配合解构赋值 for(let [key,value] of map){ console.log(key,value); } 方法 keys() 获取所有键 values() 获取所有值 entries() 获取所有键值对，返回类数组 Set集合Set集合，类似于数组，但是成员的值都是唯一的，没有重复的值。 let imgs = new Set(); imgs.add(1）; imgs.add(1); imgs.add(5); imgs.add(&quot;5&quot;); imgs.add(new String(&quot;abc&quot;)）; imgs.add(new String(&quot;abc&quot;)）; //打印的结果： 1 5 &#39;5&#39; &#39;abc&#39; &#39;abc&#39; Set集合是默认去重复的，但前提是两个添加的元素严格相等，所以5和”5”不相等，两个new出来的字符串不相等 [案例] 去重数组 SET集合没有提供下标方式的访问，因此只能使用for…of来遍历。由于Set集合本质上还是一个map，因此会有以下几种遍历方法 var imgs = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]); //根据KEY遍历 for(let item of imgs.keys()){ console.log(item); } //a //b //c //根据VALUE遍历 for(let item of imgs.values()){ console.log(item); } //a //b //c //根据KEY-VALUE遍历 for(let item of imgs.entries()){ console.log(item); } //[&#39;a&#39;,&#39;a&#39;] //[&#39;b&#39;,&#39;b&#39;] //[&#39;c&#39;,&#39;c&#39;] //普通for...of循环 for(let item of imgs){ console.log(item); } //a //b //c","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lee.js.org/Cat/tags/ES6/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"vue与echarts显示隐藏","slug":"vue与echarts显示隐藏","date":"2018-08-22T10:44:57.000Z","updated":"2019-03-08T04:04:42.097Z","comments":true,"path":"2018/08/22/vue与echarts显示隐藏/","link":"","permalink":"https://lee.js.org/Cat/2018/08/22/vue与echarts显示隐藏/","excerpt":"随着项目需求，我们有时候会用到vue+echarts；有时候ecahrts图表需要在适当的时候进行显示隐藏，对于众多vue使用者来说显示隐藏==&gt;v-show;我也不例外。使用v-show的确可以做到显示隐藏但是echarts图表的宽高会不受控制。","text":"随着项目需求，我们有时候会用到vue+echarts；有时候ecahrts图表需要在适当的时候进行显示隐藏，对于众多vue使用者来说显示隐藏==&gt;v-show;我也不例外。使用v-show的确可以做到显示隐藏但是echarts图表的宽高会不受控制。 知识点在此之前我们先来理解一下vue的显示隐藏： v-show v-if这两个都可以进行显示隐藏，不过v-show相当于加了属性=&gt;display:none;而v-if是不渲染改节点，这两者有着质的区别 解决方案单纯的显示隐藏对于单纯的显示隐藏使用v-if,切在的当前页面只渲染一次；这种情况使用v-if即可。当然还有给echarts图表添加属性 grid:{containLabel:true} 复杂的显示隐藏对于需要反复重新渲染的echarts图表如果使用v-if的话，初始化时是可行的，但是切换重新渲染会抛出错误 attributes is not defined。因此我们不能使用v-if; 思路： 报错原因=&gt;节点不存在 显示隐藏底层是display:none;或者opacity:0; 代码： &lt;div id=&quot;charts&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;indent&quot;&gt; &lt;div class=&quot;indent_icon&quot;&gt;&lt;/div&gt; &lt;span class=&quot;indent_ratio&quot;&gt;订单占比&lt;/span&gt; &lt;div class=&quot;indent_kong&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;myChart&quot; &gt;&lt;/div&gt; &lt;div class=&quot;indent_two&quot;&gt; &lt;div class=&quot;indent_icon&quot;&gt;&lt;/div&gt; &lt;span class=&quot;indent_ratio&quot;&gt;订单趋势&lt;/span&gt; &lt;span class=&quot;rise&quot; v-show=&quot;isactive!=1&quot;&gt;{{huanbi}}&lt;/span&gt; &lt;span class=&quot;increase&quot; v-show=&quot;isactive!=1&quot;&gt;环比增长&lt;/span&gt; &lt;div class=&quot;indent_kong&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;myChart_two&quot; :style=&quot;{width: &#39;100%&#39;, height: &#39;300px&#39;,&#39;margin-bottom&#39;:&#39;1rem&#39;,}&quot;&gt;&lt;/div&gt; &lt;/div&gt; 重新渲染: getEcharts:function(){ //echarts图表数据 var USaferss={ Action:&quot;/Itil/face/V1801090100.G.JSON&quot;, Result:{}, Values:{ // select:&#39;time&#39;, //staDate:&#39;2017-03-06&#39; find:&#39;time2&#39;, type:this.isactive, f_itil_1801090105_E01:this.companycode, }, Upload:false, Finish:(v)=&gt;{ var Sv=v.data.OutData; this.times = Sv; this.huanbi = this.times.seq; this.all = this.times.all; console.log( this.huanbi); console.log(this.times.appli); console.log(Sv); var charts = document.getElementById(&#39;charts&#39;); if( this.all==0){ charts.style.display=&quot;none&quot;; }else{ charts.style.display=&quot;block&quot;; this.drawLine(this.times); this.drawLinetwo(this.times); } }, Errors:(v)=&gt;{} }; this.PstData(USaferss,&quot;G&quot;); }, 这样我们就可以实时切换图表了，无数据则隐藏，有数据就显示；默认一定要是隐藏状态o,希望对你有所帮助！","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://lee.js.org/Cat/tags/Echarts/"},{"name":"Vue","slug":"Vue","permalink":"https://lee.js.org/Cat/tags/Vue/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"Vue 小程序表达式","slug":"Vue-小程序表达式","date":"2018-08-03T09:10:03.000Z","updated":"2019-03-08T04:05:04.267Z","comments":true,"path":"2018/08/03/Vue-小程序表达式/","link":"","permalink":"https://lee.js.org/Cat/2018/08/03/Vue-小程序表达式/","excerpt":"最近写了很多动态添加类名或者tab标签切换的表达式，遇到过很多的坑，下面为大家分享一下我遇到的几种。","text":"最近写了很多动态添加类名或者tab标签切换的表达式，遇到过很多的坑，下面为大家分享一下我遇到的几种。 v-show以及微信wx:if的使用（以这两个为例）v-showv-show后面可以在引号里面直接写true or false &lt;span class=&quot;rise&quot; v-show=&quot;isactive!=1&quot;&gt;{{huanbi}}&lt;/span&gt; &lt;span class=&quot;rise&quot; v-show=&quot;false&quot;&gt;{{huanbi}}&lt;/span&gt; &lt;span class=&quot;rise&quot; v-show=&quot;true&quot;&gt;{{huanbi}}&lt;/span&gt; wx:ifwx:if在引号里面必须有{{}} # 在hexojs中直接写{{}}会抛出环境错误 &lt;view wx:if=&quot;{{false}}&quot; class=&quot;Theuser&quot; style=&quot;height:85rpx;&quot;&gt; &lt;label&gt;渠道编号：&lt;/label&gt; &lt;view style=&quot;height:100%;float:right;margin-right:24rpx;line-height:88rpx;&quot;&gt;{{qudaocode}}&lt;/view&gt; &lt;/view&gt; 注：在使用wx:if时有时候会出现闪现问题，其一先清除默认值，其二要使用全等 v-for与wx:forv-for &lt;div class=&quot;list&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :price=&quot;[item.f_itil_1801090109_006]&quot; :name=&quot;[item.f_itil_1801090109_P01]&quot;&gt; 如果需要使用索引 &lt;li v-for=&quot;item in items&quot;&gt; {{parentMessage}} - {{$index}} - {{item.message}} &lt;/li&gt; &lt;div v-for=&quot;(index, item) in items&quot;&gt; {{index}} {{item.message}} &lt;/div&gt; wx:forwx:for=&quot;{{Alldata}}&quot; wx:key=&quot;&quot; #Alldata 为数组 使用索引时直接用{{index}}即可 三元运算&lt;div class=&quot;btn_date&quot; @click=&quot;choose&quot;&gt; &lt;span class=&quot;er&quot; :class=&quot;[status==1?&#39;active&#39;:&#39;&#39;]&quot; :name=&quot;1&quot;&gt;日&lt;/span&gt; &lt;span class=&quot;er&quot; :class=&quot;[status==2?&#39;active&#39;:&#39;&#39;]&quot; :name=&quot;2&quot;&gt;周&lt;/span&gt; &lt;span class=&quot;er&quot; :class=&quot;[status==3?&#39;active&#39;:&#39;&#39;]&quot; :name=&quot;3&quot;&gt;月&lt;/span&gt; &lt;span class=&quot;er&quot; :class=&quot;[status==4?&#39;active&#39;:&#39;&#39;]&quot; :name=&quot;4&quot;&gt;年&lt;/span&gt; &lt;/div&gt; //简单的点击添加类名 &lt;view class=&quot;header&quot; bindtap=&quot;choosetype&quot;&gt; &lt;view class=&quot;{{isactive == 1?'active':''}}&quot; data-set=&quot;1&quot;&gt;全部&lt;/view&gt; &lt;view class=&quot;{{isactive == 2?'active':''}}&quot; data-set=&quot;2&quot;&gt;待接单&lt;/view&gt; &lt;view class=&quot;{{isactive == 3?'active':''}}&quot; data-set=&quot;3&quot;&gt;处理中&lt;/view&gt; &lt;view class=&quot;{{isactive == 4?'active':''}}&quot; data-set=&quot;4&quot;&gt;已完成&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;header&quot; bindtap=&quot;choosetype&quot;&gt; &lt;view class=&quot;er {{isactive == 1?'active':''}}&quot; data-set=&quot;1&quot;&gt;全部&lt;/view&gt; &lt;view class=&quot;er {{isactive == 2?'active':''}}&quot; data-set=&quot;2&quot;&gt;待接单&lt;/view&gt; &lt;view class=&quot;er {{isactive == 3?'active':''}}&quot; data-set=&quot;3&quot;&gt;处理中&lt;/view&gt; &lt;view class=&quot;er {{isactive == 4?'active':''}}&quot; data-set=&quot;4&quot;&gt;已完成&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;header&quot; bindtap=&quot;choosetype&quot;&gt; &lt;view class=&quot;{{isactive == 1?'active er':'er'}}&quot; data-set=&quot;1&quot;&gt;全部&lt;/view&gt; &lt;view class=&quot;{{isactive == 2?'active er':'er'}}&quot; data-set=&quot;2&quot;&gt;待接单&lt;/view&gt; &lt;view class=&quot;{{isactive == 3?'active er':'er'}}&quot; data-set=&quot;3&quot;&gt;处理中&lt;/view&gt; &lt;view class=&quot;{{isactive == 4?'active er':'er'}}&quot; data-set=&quot;4&quot;&gt;已完成&lt;/view&gt; &lt;/view&gt; 注：小程序里面不能写2个class会报错，vue可以写 &lt;image src=&quot;{{ischoose=='1'?[chec;]:[uncheck]}}&quot;&gt;&lt;/image&gt; #### data:{ chec:&#39;wwqeq&#39;, uncheck:&#39;sdsadasd&#39; } 未完待续","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lee.js.org/Cat/tags/Vue/"},{"name":"Mini-apps","slug":"Mini-apps","permalink":"https://lee.js.org/Cat/tags/Mini-apps/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"移动端拖拽","slug":"移动端拖拽","date":"2018-07-23T09:56:10.000Z","updated":"2019-03-08T04:04:53.247Z","comments":true,"path":"2018/07/23/移动端拖拽/","link":"","permalink":"https://lee.js.org/Cat/2018/07/23/移动端拖拽/","excerpt":"最近在做一个混合开发的项目，需求里面要求使用拖拽，然而这不是jq的拖拽；我向很多大佬求助过，有一位大佬建议我去使用hammer.js;由于时间紧迫我不得不放弃这一方法。还有大佬向我推荐vue封装的插件，然而我试了一下有局限性，position:absolute==&gt;我想要是的fixed；还有通过指令的方法等等我都试了不好用；求人不如求己下面我将为大家介绍一种简单的方法（适用于vue）","text":"最近在做一个混合开发的项目，需求里面要求使用拖拽，然而这不是jq的拖拽；我向很多大佬求助过，有一位大佬建议我去使用hammer.js;由于时间紧迫我不得不放弃这一方法。还有大佬向我推荐vue封装的插件，然而我试了一下有局限性，position:absolute==&gt;我想要是的fixed；还有通过指令的方法等等我都试了不好用；求人不如求己下面我将为大家介绍一种简单的方法（适用于vue） 完整代码展示 &lt;template&gt; &lt;div class=&quot;detail&quot;&gt; &lt;!-- 头部 --&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;!-- 报障人信息 --&gt; &lt;app-person&gt;&lt;/app-person&gt; &lt;!-- 报障内容 --&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;!-- 处理进度 --&gt; &lt;app-progress&gt;&lt;/app-progress&gt; &lt;!-- 底部导航栏 --&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;!-- 遮罩层 --&gt; &lt;div class=&quot;home&quot; id=&quot;moveDiv&quot; @click=&quot;gohome&quot; @touchstart=&quot;down&quot; @touchmove=&quot;move&quot; @touchend=&quot;end&quot;&gt; &lt;img src=&quot;../../../../Img/img/home.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import AppHeader from &quot;./vue/header.vue&quot;; import AppPerson from &quot;./vue/person.vue&quot;; import AppContent from &quot;./vue/content.vue&quot;; import AppProgress from &quot;./vue/progress.vue&quot;; import AppNav from &quot;./vue/nav.vue&quot;; // import AppMask from &#39;./vue/mask.vue&#39;; export default { data() { return { flags: false, position: { x: 0, y: 0 }, nx: &#39;&#39;, ny: &#39;&#39;, dx: &#39;&#39;, dy: &#39;&#39;, xPum: &#39;&#39;, yPum: &#39;&#39;, }; }, methods: { gohome:function(){ //跳转home this.$router.push({ name:&#39;index&#39;, // query:{engineerNum:this.engineerNum} }) }, down(){ console.log(&#39;down&#39;); this.flags = true; var touch ; if(event.touches){ touch = event.touches[0]; }else { touch = event; } this.position.x = touch.clientX; this.position.y = touch.clientY; this.dx = moveDiv.offsetLeft; this.dy = moveDiv.offsetTop; }, preHandler:function(e){ e.preventDefault(); }, move(){ console.log(&#39;move&#39;); if(this.flags){ var touch ; if(event.touches){ touch = event.touches[0]; }else { touch = event; } this.nx = touch.clientX - this.position.x; this.ny = touch.clientY - this.position.y; this.xPum = this.dx+this.nx; this.yPum = this.dy+this.ny; moveDiv.style.left = this.xPum+&quot;px&quot;; moveDiv.style.top = this.yPum +&quot;px&quot;; //阻止页面的滑动默认事件 document.addEventListener(&quot;touchmove&quot;,this.preHandler,false); } }, end(){ console.log(&#39;end&#39;); //alert(e3); this.flags = false; document.removeEventListener(&#39;touchmove&#39;, this.preHandler, false); }, }, components: { AppHeader, AppPerson, AppContent, AppProgress, AppNav // AppMask } }; &lt;/script&gt; &lt;style scoped lang=&quot;less&quot;&gt; .detail { position: relative; min-height:100%; } .home{ position:fixed; right:.2rem; bottom:15%; line-height:1rem; width:.98rem; height:.98rem; img{ width:.98rem; height:.98rem; } } &lt;/style&gt; 相关知识点touchstart当在屏幕上按下手指时触发touchmove 当在屏幕上移动手指时触发 touchend 当在屏幕上抬起手指时触发mousedown mousemove mouseup对应的是PC端的事件 touchcancel 当一些更高级别的事件发生的时候（如电话接入或者弹出信息）会取消当前的touch操作，即触发touchcancel。一般 会在touchcancel时暂停游戏、存档等操作。 效果图（非对应的界面由于环境问题） 步骤详解HTML &lt;div class=&quot;detail&quot;&gt; &lt;div class=&quot;home&quot; id=&quot;moveDiv&quot; @click=&quot;gohome&quot; @touchstart=&quot;down&quot; @touchmove=&quot;move&quot; @touchend=&quot;end&quot;&gt; &lt;img src=&quot;../../../../Img/img/home.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; JS down(){ console.log(&#39;down&#39;); this.flags = true; var touch ; if(event.touches){ touch = event.touches[0]; }else { touch = event; } this.position.x = touch.clientX; this.position.y = touch.clientY; this.dx = moveDiv.offsetLeft; this.dy = moveDiv.offsetTop; }, preHandler:function(e){ e.preventDefault(); }, move(){ console.log(&#39;move&#39;); if(this.flags){ var touch ; if(event.touches){ touch = event.touches[0]; }else { touch = event; } this.nx = touch.clientX - this.position.x; this.ny = touch.clientY - this.position.y; this.xPum = this.dx+this.nx; this.yPum = this.dy+this.ny; moveDiv.style.left = this.xPum+&quot;px&quot;; moveDiv.style.top = this.yPum +&quot;px&quot;; //阻止页面的滑动默认事件 document.addEventListener(&quot;touchmove&quot;,this.preHandler,false); } }, end(){ console.log(&#39;end&#39;); //alert(e3); this.flags = false; document.removeEventListener(&#39;touchmove&#39;, this.preHandler, false); }, CSS.detail { position: relative; min-height:100%; } .home{ position:fixed; right:.2rem; bottom:15%; line-height:1rem; width:.98rem; height:.98rem; img{ width:.98rem; height:.98rem; }","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lee.js.org/Cat/tags/Vue/"},{"name":"Mobileterminal","slug":"Mobileterminal","permalink":"https://lee.js.org/Cat/tags/Mobileterminal/"},{"name":"Drag","slug":"Drag","permalink":"https://lee.js.org/Cat/tags/Drag/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"移动端键盘弹起，底部按钮顶上去另类解决办法(Vue)","slug":"Vue键盘弹起","date":"2018-07-17T07:12:43.000Z","updated":"2019-03-08T04:04:40.481Z","comments":true,"path":"2018/07/17/Vue键盘弹起/","link":"","permalink":"https://lee.js.org/Cat/2018/07/17/Vue键盘弹起/","excerpt":"当我们写一个页面有键盘弹起且底部按钮fixed时你会发现点击输入框是底部按钮会弹起，网上很多方法但是只适用于对应的场景,今天我们来学习一种Vue 页面的键盘弹起。","text":"当我们写一个页面有键盘弹起且底部按钮fixed时你会发现点击输入框是底部按钮会弹起，网上很多方法但是只适用于对应的场景,今天我们来学习一种Vue 页面的键盘弹起。 解决办法：换个思路，检测浏览器的resize事件，当高度过小时就可以判定为出现这种情况，这时把定位改成ab或者直接隐藏掉之类的。 方法一&lt;mt-button v-show=&quot;isOriginHei&quot; class=&quot;add-client&quot; type=&quot;default&quot; size=&quot;large&quot; @click.native=&quot;submitClientInfo&quot;&gt;&lt;icon-svg iconClass=&quot;baocun&quot; class=&quot;icon-xinzeng&quot;&gt;&lt;/icon-svg&gt;提交&lt;/mt-button&gt; 第一步： 先在 data 中去 定义 一个记录高度是 属性data: { screenHeight: document.body.clientHeight// 这里是给到了一个默认值 （这个很重要）， originHeight: document.body.clientHeight//默认高度在watch里拿来做比较 } 第二步： 我们需要 讲 reisze 事件在 vue mounted 的时候 去挂载一下它的方法mounted () { const that = this window.onresize = () =&gt; { return (() =&gt; { window.screenHeight= document.body.clientHeight that.screenHeight= window.screenHeight })() } } 第三步： watch 去监听这个 属性值的变化，如果发生变化则讲这个val 传递给 this.screenHeightwatch: { screenHeight(val) { this.screenHeight= val } } watch监控比较，判断按钮是否该显示出来watch: { screenHeight (val) { if(this.originHeight != val) { this.isOriginHei = false; }else{ this.isOriginHei = true; } } } 方法二步骤一：定义一个指令 footlet listenAction; let originalHeight; let currHeight; export default new Object().install = (Vue, options = {}) =&gt; { Vue.directive(&#39;foot&#39;, { insert(el, binding) { const elStyle = el.style; let active = false; originalHeight = document.body.clientHeight; const reset = () =&gt; { if(!active) { return ; } elStyle.display = &#39;flex&#39;; active = false; } const hang = () =&gt; { if(active) { return ; } elStyle.display = &#39;none&#39; active = true; } const getCurrHeight = () =&gt; { let getHeight = document.body.clientHeight; return getHeight; } const check = () =&gt; { currHeight = getCurrHeight(); if(currHeight != originalHeight) { hang(); }else { reset(); } } listenAction = () =&gt; { check() } window.addEventListener(&#39;resize&#39;, listenAction); }, unbind() { window.removeEventListener(&#39;resize&#39;,listenAction); } }) } 步骤二：组件引用import Foot from &#39;libs/foot&#39; Vue.use(Foot) 步骤三：指令使用&lt;m-flex class=&quot;pay-group&quot; v-foot&gt; &lt;m-flex-item class=&quot;should-pay&quot;&gt;应付金额：&lt;span&gt;￥99&lt;/span&gt;&lt;/m-flex-item&gt; &lt;m-button @click=&quot;goPay&quot; class=&quot;pay-btn&quot;&gt;去支付&lt;/m-button&gt; &lt;/m-flex&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lee.js.org/Cat/tags/Vue/"},{"name":"Mobileterminal","slug":"Mobileterminal","permalink":"https://lee.js.org/Cat/tags/Mobileterminal/"},{"name":"resize","slug":"resize","permalink":"https://lee.js.org/Cat/tags/resize/"},{"name":"absolute","slug":"absolute","permalink":"https://lee.js.org/Cat/tags/absolute/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"从零开始小程序","slug":"从零开始小程序","date":"2018-07-13T01:16:24.000Z","updated":"2019-03-08T04:04:39.659Z","comments":true,"path":"2018/07/13/从零开始小程序/","link":"","permalink":"https://lee.js.org/Cat/2018/07/13/从零开始小程序/","excerpt":"随着技术的发展着2年微信小程序犹如一匹黑马迅速崛起，新的技术出现，我们为了不与时代脱轨学习小程序很有必要！","text":"随着技术的发展着2年微信小程序犹如一匹黑马迅速崛起，新的技术出现，我们为了不与时代脱轨学习小程序很有必要！ 开始学习准备工作 IDE搭建 知识准备 从零开始 app.js app.json app.wxml app.wxss Hello World 创建程序实例 美化ActionBar 美化页面 配置首页 超级Hello World 事件绑定函数 更新界面数据 准备工作IDE搭建就不多说了，没有内测码去下载个破解版吧，我用了一下，学习完全够了！IDE破解版+安装教程 知识准备JavaScrip还是要看看的，推荐教程 廖雪峰大神的博客 HTML+CSS 大概知道是干啥的就行 从零开始微信小程序中就四种类型的文件 js ———- JavaScrip文件 json ——– 项目配置文件，负责窗口颜色等等 wxml ——- 类似HTML文件 wxss ——- 类似CSS文件 在根目录下用app来命名的这四中类型的文件，就是程序入口文件 app.json 必须要有这个文件，如果没有这个文件，IDE会报错，因为微信框架把这个作为配置文件入口，你只需创建这个文件，里面写个大括号就行以后我们会在这里对整个小程序的全局配置。记录了页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 这个文件不是必须的。因为它只是个全局CSS样式文件 app.wxml 这个也不是必须的，而且这个并不是指主界面哦~因为小程序的主页面是靠在JSON文件中配置来决定的 有了这两个文件你运行程序，IDE就不会报错了，也意味着这是最简单的微信小程序 Hello World创建程序实例app.js文件管理整个程序的生命周期，所以在里面添加如下代码：（输入App IDE会有提示） App({ onLaunch: function () { console.log(&#39;App Launch&#39;) }, onShow: function () { console.log(&#39;App Show&#39;) }, onHide: function () { console.log(&#39;App Hide&#39;) } }) 具体API解释如下: 美化ActionBarjson文件负责配置ActionBar颜色，我们只需要在里面添加如下代码即可，下图有参数说明！ { &quot;window&quot;:{ &quot;navigationBarBackgroundColor&quot;: &quot;#BBDEF8&quot;, &quot;navigationBarTitleText&quot;: &quot;Demo&quot;, &quot;navigationBarTextStyle&quot;:&quot;white&quot; } } 现在看ActionBar是不是像那么回事了！好接下来我们继续写我们第一个界面 美化页面美化页面我没用到了wxml和wxssw文件为了程序代码结构简洁我们需要在根目录下创建一个新文件夹 名字随意， 我们这里叫pages然后在pages文件夹里面再创建新文件夹 名字随意, 这里我没叫index然后我们创建index.wxml文件然后在里面写入以下代码： &lt;view&gt; &lt;text class=&quot;window&quot;&gt;Hello&lt;/text&gt; &lt;/view&gt; 然后创建index.wxss文件然后在里面写下以下代码 .window{ color:#4995fa; } 然后我们创建 index.js在文件中输入如下代码（输入Page IDE会有提示） Page({ data:{ // text:&quot;这是一个页面&quot; }, onLoad:function(options){ // 页面初始化 options为页面跳转所带来的参数 }, onReady:function(){ // 页面渲染完成 }, onShow:function(){ // 页面显示 }, onHide:function(){ // 页面隐藏 }, onUnload:function(){ // 页面关闭 } }) 函数解释如下： 配置首页Json文件负责配置页面路径所以我们在里面加入如下代码 其中index的含义 其实就是指index.js文件这里需要说明一点 pages 里面的路径其实是指向js文件的 如果一个目录下没有该名称的js文件是会报错的！ &quot;pages&quot;:[ &quot;pages/index/index&quot;], 完成了！我们来运行程序！ 超级Hello World为了学习事件绑定，以及如何将数据在页面上更新我们来做个超级Hello World，就是我点击文字，能让它变色！ 绑定事件我们打开index.wxml 将里面代码改成这样 &lt;view&gt; &lt;text catchtap=&quot;click&quot; class=&quot;window&quot;&gt;Hello&lt;/text&gt;&lt;/view&gt; 其实也就是加了： catchtap=&quot;click&quot;//bindtap=&#39;click&#39; 这两个属性是什么意思呢 别着急 我会一一解释 上图展示了事件的一些的属性名称，这里需要注意红框标注起来的内容，区分出冒泡事件和非冒泡事件，其实冒泡事件就是需要往上面一层容器传递这个事件 看了这图 我们再来看 catchtap=”click” 的含义catch 代表非冒泡事件tap 代表点击事件所以连在一起就是非冒泡点击事件那后面那个click是啥click 其实只是个变量名字我们在index.js需要用这个名字绑定接收事件的函数我们打开index.js然后添加如下函数 click:function(){ console.log(&quot;点击了文字&quot;); } ,添加完后代码长这样 红框中就是 添加的这个代码 所以其实点击事件的回调函数 就是 catchtap=”click” 中的 click 后面加上 :function() 构成的现在我们来运行程序试试 然后点击文字 看是不是调用了click:function 并打印 点击了文字 好接下来我们写点击一下变色的逻辑那如何让一个文字变色呢，当然是css所以我们需要再index.wxss 中添加一个样式 .window-red{ color:#D23933;} .window{color:#49bb16;} .window-red{color:#D23933;} 然后我们进入index.js文件你会发现代码里面有个 data:{} 它不是page生命周期函数其实他是个变量的数组，这个里面申请的变量都可以在 wxml中使用 data:{ color:&quot;window&quot; } color的值就是index.wxss中的样式名称然后进入index.wxml中,将class中的值改成 &lt;view&gt; &lt;text catchtap=&#39;click&#39; class=&quot;{{color}}&quot;&gt;Hello&lt;/text&gt; &lt;/view&gt; 其实意思就是 将js文件中变量 color的值在这里使用也就是值等于 window然后我们再回到index.js文件在最上面申请一个变量控制点击然后在click:function() 函数中添加如下代码: click:function(){ console.log(&quot;点击了文字&quot;); if(flag){ color = &quot;window-red&quot;; flag = false; } else{ color = &quot;window&quot;; flag = true; } this.setData({ color }); }, 完后的代码如图: 其实就是在点击是后 更换color变量的值 而更换的这个值其实就是样式的名称 更新界面数据这里有个问题 我们更换完值 但是在wxml中不会立即生效所以我们需要调用this.setData()方法将值同步给wxml 让它立即生效 好了我们运行程序 点击Hello 看看是不是点一下 变一下颜色！ 最后再补充一点 index目录下也是可以配置 json文件的也就是每个页面都可以配置自己独特的actionbar颜色等等这里的配置会覆盖 app.json文件的配置","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Mini-apps","slug":"Mini-apps","permalink":"https://lee.js.org/Cat/tags/Mini-apps/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"Echarts属性设置","slug":"Echarts属性设置","date":"2018-07-12T09:53:47.000Z","updated":"2019-03-08T04:05:24.966Z","comments":true,"path":"2018/07/12/Echarts属性设置/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/Echarts属性设置/","excerpt":"Echarts: 千万级数据可视化渲染能力 SVG + Canvas 双引擎动力更佳 数据样式分离及扁平配置让开发更便捷 首创无障碍访问支持 微信小程序、PPT，哪里都能用","text":"Echarts: 千万级数据可视化渲染能力 SVG + Canvas 双引擎动力更佳 数据样式分离及扁平配置让开发更便捷 首创无障碍访问支持 微信小程序、PPT，哪里都能用 全图默认背景backgroundColor: ‘rgba(0,0,0,0)’, 默认色板color: [&#39;#ff7f50&#39;,&#39;#87cefa&#39;,&#39;#da70d6&#39;,&#39;#32cd32&#39;,&#39;#6495ed&#39;, &#39;#ff69b4&#39;,&#39;#ba55d3&#39;,&#39;#cd5c5c&#39;,&#39;#ffa500&#39;,&#39;#40e0d0&#39;, &#39;#1e90ff&#39;,&#39;#ff6347&#39;,&#39;#7b68ee&#39;,&#39;#00fa9a&#39;,&#39;#ffd700&#39;, &#39;#6699FF&#39;,&#39;#ff6666&#39;,&#39;#3cb371&#39;,&#39;#b8860b&#39;,&#39;#30e0e0&#39;], 图表标题title: { x: &#39;left&#39;, // 水平安放位置，默认为左对齐，可选为： // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39; // ¦ {number}（x坐标，单位px） y: &#39;top&#39;, // 垂直安放位置，默认为全图顶端，可选为： // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39; // ¦ {number}（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: &#39;rgba(0,0,0,0)&#39;, borderColor: &#39;#ccc&#39;, // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: { fontSize: 18, fontWeight: &#39;bolder&#39;, color: &#39;#333&#39; // 主标题文字颜色 }, subtextStyle: { color: &#39;#aaa&#39; // 副标题文字颜色 } }, 图例legend: { orient: &#39;horizontal&#39;, // 布局方式，默认为水平布局，可选为： // &#39;horizontal&#39; ¦ &#39;vertical&#39; x: &#39;center&#39;, // 水平安放位置，默认为全图居中，可选为： // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39; // ¦ {number}（x坐标，单位px） y: &#39;top&#39;, // 垂直安放位置，默认为全图顶端，可选为： // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39; // ¦ {number}（y坐标，单位px） backgroundColor: &#39;rgba(0,0,0,0)&#39;, borderColor: &#39;#ccc&#39;, // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: { color: &#39;#333&#39; // 图例文字颜色 } }, 值域dataRange: { orient: &#39;vertical&#39;, // 布局方式，默认为垂直布局，可选为： // &#39;horizontal&#39; ¦ &#39;vertical&#39; x: &#39;left&#39;, // 水平安放位置，默认为全图左对齐，可选为： // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39; // ¦ {number}（x坐标，单位px） y: &#39;bottom&#39;, // 垂直安放位置，默认为全图底部，可选为： // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39; // ¦ {number}（y坐标，单位px） backgroundColor: &#39;rgba(0,0,0,0)&#39;, borderColor: &#39;#ccc&#39;, // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:[&#39;#1e90ff&#39;,&#39;#f0ffff&#39;],//颜色 //text:[&#39;高&#39;,&#39;低&#39;], // 文本，默认为数值文本 textStyle: { color: &#39;#333&#39; // 值域文字颜色 } }, 工具箱toolbox: { orient: &#39;horizontal&#39;, // 布局方式，默认为水平布局，可选为： // &#39;horizontal&#39; ¦ &#39;vertical&#39; x: &#39;right&#39;, // 水平安放位置，默认为全图右对齐，可选为： // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39; // ¦ {number}（x坐标，单位px） y: &#39;top&#39;, // 垂直安放位置，默认为全图顶端，可选为： // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39; // ¦ {number}（y坐标，单位px） color : [&#39;#1e90ff&#39;,&#39;#22bb22&#39;,&#39;#4b0082&#39;,&#39;#d2691e&#39;], backgroundColor: &#39;rgba(0,0,0,0)&#39;, // 工具箱背景颜色 borderColor: &#39;#ccc&#39;, // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : {}, // 自定义图片icon featureTitle : { mark : &#39;辅助线开关&#39;, markUndo : &#39;删除辅助线&#39;, markClear : &#39;清空辅助线&#39;, dataZoom : &#39;区域缩放&#39;, dataZoomReset : &#39;区域缩放后退&#39;, dataView : &#39;数据视图&#39;, lineChart : &#39;折线图切换&#39;, barChart : &#39;柱形图切换&#39;, restore : &#39;还原&#39;, saveAsImage : &#39;保存为图片&#39; } }, 提示框tooltip: { trigger: &#39;item&#39;, // 触发类型，默认数据触发，见下图，可选为：&#39;item&#39; ¦ &#39;axis&#39; showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: &#39;rgba(0,0,0,0.7)&#39;, // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: &#39;#333&#39;, // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : &#39;line&#39;, // 默认为直线，可选为：&#39;line&#39; | &#39;shadow&#39; lineStyle : { // 直线指示器样式设置 color: &#39;#48b&#39;, width: 2, type: &#39;solid&#39; }, shadowStyle : { // 阴影指示器样式设置 width: &#39;auto&#39;, // 阴影大小 color: &#39;rgba(150,150,150,0.3)&#39; // 阴影颜色 } }, textStyle: { color: &#39;#fff&#39; } }, 区域缩放控制器dataZoom: { orient: &#39;horizontal&#39;, // 布局方式，默认为水平布局，可选为： // &#39;horizontal&#39; ¦ &#39;vertical&#39; // x: {number}, // 水平安放位置，默认为根据grid参数适配，可选为： // {number}（x坐标，单位px） // y: {number}, // 垂直安放位置，默认为根据grid参数适配，可选为： // {number}（y坐标，单位px） // width: {number}, // 指定宽度，横向布局时默认为根据grid参数适配 // height: {number}, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: &#39;rgba(0,0,0,0)&#39;, // 背景颜色 dataBackgroundColor: &#39;#eee&#39;, // 数据背景颜色 fillerColor: &#39;rgba(144,197,237,0.2)&#39;, // 填充颜色 handleColor: &#39;rgba(70,130,180,0.8)&#39; // 手柄颜色 }, 网格grid: { x: 80, y: 60, x2: 80, y2: 60, // width: {totalWidth} - x - x2, // height: {totalHeight} - y - y2, backgroundColor: &#39;rgba(0,0,0,0)&#39;, borderWidth: 1, borderColor: &#39;#ccc&#39; }, 类目轴categoryAxis: { position: &#39;bottom&#39;, // 位置 nameLocation: &#39;end&#39;, // 坐标轴名字位置，支持&#39;start&#39; | &#39;end&#39; boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: &#39;#48b&#39;, width: 2, type: &#39;solid&#39; } }, axisTick: { // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: &#39;auto&#39;, // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: &#39;#333&#39;, width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, interval: &#39;auto&#39;, rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: &#39;#333&#39; } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: [&#39;#ccc&#39;], width: 1, type: &#39;solid&#39; } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;] } } }, 数值型坐标轴默认参数valueAxis: { position: &#39;left&#39;, // 位置 nameLocation: &#39;end&#39;, // 坐标轴名字位置，支持&#39;start&#39; | &#39;end&#39; nameTextStyle: {}, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: &#39;#48b&#39;, width: 2, type: &#39;solid&#39; } }, axisTick: { // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: &#39;#333&#39;, width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: &#39;#333&#39; } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: [&#39;#ccc&#39;], width: 1, type: &#39;solid&#39; } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;] } } }, polar : { center : [&#39;50%&#39;, &#39;50%&#39;], // 默认全局居中 radius : &#39;75%&#39;, startAngle : 90, splitNumber : 5, name : { show: true, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: &#39;#333&#39; } }, axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: &#39;#ccc&#39;, width: 1, type: &#39;solid&#39; } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: &#39;#333&#39; } }, splitArea : { show : true, areaStyle : { color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;] } }, splitLine : { show : true, lineStyle : { width : 1, color : &#39;#ccc&#39; } } }, 柱形图默认参数bar: { barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: &#39;30%&#39;, // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : &#39;20%&#39;, // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: { normal: { // color: &#39;各异&#39;, barBorderColor: &#39;#fff&#39;, // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为 // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: &#39;各异&#39;, barBorderColor: &#39;rgba(0,0,0,0)&#39;, // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为 // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, 折线图默认参数line: { itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为 // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle: { width: 2, type: &#39;solid&#39;, shadowColor : &#39;rgba(0,0,0,0)&#39;, //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为 // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } }, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） }, K线图默认参数k: { // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: { normal: { color: &#39;#fff&#39;, // 阳线填充颜色 color0: &#39;#00aa11&#39;, // 阴线填充颜色 lineStyle: { width: 1, color: &#39;#ff3200&#39;, // 阳线边框颜色 color0: &#39;#00aa11&#39; // 阴线边框颜色 } }, emphasis: { // color: 各异, // color0: 各异 } } }, 散点图默认参数scatter: { //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000, // 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为 // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: &#39;各异&#39; label: { show: false // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为 // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, 雷达图默认参数radar : { itemStyle: { normal: { // color: 各异, label: { show: false }, lineStyle: { width: 2, type: &#39;solid&#39; } }, emphasis: { // color: 各异, label: { show: false } } }, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 }, 饼图默认参数pie: { center : [&#39;50%&#39;, &#39;50%&#39;], // 默认全局居中 radius : [0, &#39;75%&#39;], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: { normal: { // color: 各异, borderColor: &#39;#fff&#39;, borderWidth: 1, label: { show: true, position: &#39;outer&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: true, length: 20, lineStyle: { // color: 各异, width: 1, type: &#39;solid&#39; } } }, emphasis: { // color: 各异, borderColor: &#39;rgba(0,0,0,0)&#39;, borderWidth: 1, label: { show: false // position: &#39;outer&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: false, length: 20, lineStyle: { // color: 各异, width: 1, type: &#39;solid&#39; } } } } }, 地图默认参数map: { mapType: &#39;china&#39;, // 各省的mapType暂时都用中文 mapLocation: { x : &#39;center&#39;, y : &#39;center&#39; // width // 自适应 // height // 自适应 }, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: { normal: { // color: 各异, borderColor: &#39;#fff&#39;, borderWidth: 1, areaStyle: { color: &#39;#ccc&#39; //rgba(135,206,250,0.8) }, label: { show: false, textStyle: { color: &#39;rgba(139,69,19,1)&#39; } } }, emphasis: { // 也是选中样式 // color: 各异, borderColor: &#39;rgba(0,0,0,0)&#39;, borderWidth: 1, areaStyle: { color: &#39;rgba(255,215,0,0.8)&#39; }, label: { show: false, textStyle: { color: &#39;rgba(139,69,19,1)&#39; } } } } }, 关系图默认参数force : { // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: { normal: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : { brushType : &#39;both&#39;, color : &#39;#f08c2e&#39;, strokeColor : &#39;#5182ab&#39; }, linkStyle : { strokeColor : &#39;#5182ab&#39; } }, emphasis: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : {}, linkStyle : {} } } }, 弦图chord : { radius : [&#39;65%&#39;, &#39;75%&#39;], center : [&#39;50%&#39;, &#39;50%&#39;], padding : 2, sort : &#39;none&#39;, // can be &#39;none&#39;, &#39;ascending&#39;, &#39;descending&#39; sortSub : &#39;none&#39;, // can be &#39;none&#39;, &#39;ascending&#39;, &#39;descending&#39; startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : { normal : { label : { show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : { width : 0, color : &#39;#000&#39; }, chordStyle : { lineStyle : { width : 1, color : &#39;#666&#39; } } }, emphasis : { lineStyle : { width : 0, color : &#39;#000&#39; }, chordStyle : { lineStyle : { width : 2, color : &#39;#333&#39; } } } } }, 其他island: { r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% }, markPoint : { symbol: &#39;pin&#39;, // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: { normal: { // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: { show: true, position: &#39;inside&#39; // 可选为&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: 各异 label: { show: true // position: &#39;inside&#39; // &#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, markLine : { // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: [&#39;circle&#39;, &#39;arrow&#39;], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: { normal: { // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: { show: false, // 可选为 &#39;start&#39;|&#39;end&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; position: &#39;inside&#39;, textStyle: { // 默认使用全局文本样式，详见TEXTSTYLE color: &#39;#333&#39; } }, lineStyle: { // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: &#39;solid&#39;, shadowColor : &#39;rgba(0,0,0,0)&#39;, //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异 label: { show: false // position: &#39;inside&#39; // &#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39; // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : {} } } }, textStyle: { decoration: &#39;none&#39;, fontFamily: &#39;Arial, Verdana, sans-serif&#39;, fontFamily2: &#39;微软雅黑&#39;, // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: &#39;normal&#39;, fontWeight: &#39;normal&#39; }, 默认标志图形类型列表symbolList : [ &#39;circle&#39;, &#39;rectangle&#39;, &#39;triangle&#39;, &#39;diamond&#39;, &#39;emptyCircle&#39;, &#39;emptyRectangle&#39;, &#39;emptyTriangle&#39;, &#39;emptyDiamond&#39; ], loadingText : &#39;Loading...&#39;, // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: &#39;rgba(255,165,0,0.6)&#39;, // 拖拽提示边框颜色 calculableHolderColor: &#39;#ccc&#39;, // 可计算占位提示颜色 nameConnector: &#39; &amp; &#39;, valueConnector: &#39; : &#39;, animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: &#39;ExponentialOut&#39; //BounceOut","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://lee.js.org/Cat/tags/Echarts/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"NodeJs","slug":"NodeJs","date":"2018-07-12T09:52:24.000Z","updated":"2019-03-08T04:05:11.655Z","comments":true,"path":"2018/07/12/NodeJs/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/NodeJs/","excerpt":"","text":"尽请期待！","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://lee.js.org/Cat/categories/Nodejs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://lee.js.org/Cat/tags/NodeJs/"}],"keywords":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://lee.js.org/Cat/categories/Nodejs/"}]},{"title":"Ajax","slug":"Ajax","date":"2018-07-12T09:50:31.000Z","updated":"2019-03-08T04:04:36.869Z","comments":true,"path":"2018/07/12/Ajax/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/Ajax/","excerpt":"","text":"敬请期待！","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://lee.js.org/Cat/tags/Ajax/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"初识PHP","slug":"初识PHP","date":"2018-07-12T09:46:28.000Z","updated":"2019-03-08T04:04:38.023Z","comments":true,"path":"2018/07/12/初识PHP/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/初识PHP/","excerpt":"","text":"PHP（外文名:PHP: Hypertext Preprocessor）：超文本预处理器。是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。以前是没有前端这个职位的，随着计算机语言的发展Ajax的出现，有了前后端分离这一概念。","categories":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://lee.js.org/Cat/tags/PHP/"}],"keywords":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}]},{"title":"Nginx快速开端口","slug":"Nginx","date":"2018-07-12T09:17:00.000Z","updated":"2019-03-08T04:05:12.410Z","comments":true,"path":"2018/07/12/Nginx/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/Nginx/","excerpt":"对于一个前端来说，运行一些代码有些特殊情况需要开设端口。起初我使用静态服务器用sumlime,后面陆续使用wampserver,xampp;但是有一次换电脑了，需要重新下载，糟糕的的是突然下载不了，项目于是停止不前；庆幸的是以为Java同事告诉我用Nginx开设端口。我在这里把我这个方法分享给大家！","text":"对于一个前端来说，运行一些代码有些特殊情况需要开设端口。起初我使用静态服务器用sumlime,后面陆续使用wampserver,xampp;但是有一次换电脑了，需要重新下载，糟糕的的是突然下载不了，项目于是停止不前；庆幸的是以为Java同事告诉我用Nginx开设端口。我在这里把我这个方法分享给大家！ 第一步下载Nginx下载地址：http://nginx.org/ 第二步配置config进入conf/nignx.conf文件具体配置如下： #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; #端口 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root F:\\GitMap1\\echarts3-chinese-map-drill-down; #真实路径 index index.html index.htm; #可识别的目标文件 } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ /\\.ht { # deny all; #} } server { listen 8000; #端口 server_name localhost; location / { root F:\\GitMap1\\echarts3-chinese-map-drill-down; #真实路径 index index.html index.htm; } } server { listen 8080; server_name localhost; location / { root F:\\NewRequest\\jingqingan_ganzhou; index index.html index.htm; } } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } Windows下使用nginx命令启动在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。 启动C:\\server\\nginx-1.0.2&gt;start nginx 或 C:\\server\\nginx-1.0.2&gt;nginx.exe 注：建议使用第一种，第二种会使你的cmd窗口一直处于执行中，不能进行其他命令操作。 停止C:\\server\\nginx-1.0.2&gt;nginx.exe -s stop 或 C:\\server\\nginx-1.0.2&gt;nginx.exe -s quit 注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。 重新载入NginxC:\\server\\nginx-1.0.2&gt;nginx.exe -s reload 当配置信息修改，需要重新载入这些配置时使用此命令。 重新打开日志文件：C:\\server\\nginx-1.0.2&gt;nginx.exe -s reopen 查看Nginx版本：C:\\server\\nginx-1.0.2&gt;nginx -v","categories":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://lee.js.org/Cat/tags/Nginx/"}],"keywords":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}]},{"title":"简易Python","slug":"简易Python","date":"2018-07-12T09:04:13.000Z","updated":"2019-03-08T04:04:57.050Z","comments":true,"path":"2018/07/12/简易Python/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/简易Python/","excerpt":"Python是由吉多·范罗苏姆(Guido Van Rossum)在90年代早期设计。它是如今最常用的编程 语言之一。它的语法简洁且优美，几乎就是可执行的伪代码。 注意：这篇教程是用Python3写的。 下面一起来学习吧！","text":"Python是由吉多·范罗苏姆(Guido Van Rossum)在90年代早期设计。它是如今最常用的编程 语言之一。它的语法简洁且优美，几乎就是可执行的伪代码。 注意：这篇教程是用Python3写的。 下面一起来学习吧！ { # 用井字符开头的是单行注释 &quot;&quot;&quot; 多行字符串用三个引号 包裹，也常被用来做多 行注释 &quot;&quot;&quot; #################################################### ## 1. 原始数据类型和运算符 #################################################### # 整数 3 # =&gt; 3 # 算术运算没有什么出乎意料的 1 + 1 # =&gt; 2 8 - 1 # =&gt; 7 10 * 2 # =&gt; 20 # 但是除法例外，会自动转换成浮点数 35 / 5 # =&gt; 7.0 5 / 3 # =&gt; 1.6666666666666667 # 整数除法的结果都是向下取整 5 // 3 # =&gt; 1 5.0 // 3.0 # =&gt; 1.0 # 浮点数也可以 -5 // 3 # =&gt; -2 -5.0 // 3.0 # =&gt; -2.0 # 浮点数的运算结果也是浮点数 3 * 2.0 # =&gt; 6.0 # 模除 7 % 3 # =&gt; 1 # x的y次方 2**4 # =&gt; 16 # 用括号决定优先级 (1 + 3) * 2 # =&gt; 8 # 布尔值 True False # 用not取非 not True # =&gt; False not False # =&gt; True # 逻辑运算符，注意and和or都是小写 True and False #=&gt; False False or True #=&gt; True # 整数也可以当作布尔值 0 and 2 #=&gt; 0 -5 or 0 #=&gt; -5 0 == False #=&gt; True 2 == True #=&gt; False 1 == True #=&gt; True # 用==判断相等 1 == 1 # =&gt; True 2 == 1 # =&gt; False # 用!=判断不等 1 != 1 # =&gt; False 2 != 1 # =&gt; True # 比较大小 1 &lt; 10 # =&gt; True 1 &gt; 10 # =&gt; False 2 &lt;= 2 # =&gt; True 2 &gt;= 2 # =&gt; True # 大小比较可以连起来！ 1 &lt; 2 &lt; 3 # =&gt; True 2 &lt; 3 &lt; 2 # =&gt; False # 字符串用单引双引都可以 &quot;这是个字符串&quot; &#39;这也是个字符串&#39; # 用加号连接字符串 &quot;Hello &quot; + &quot;world!&quot; # =&gt; &quot;Hello world!&quot; # 字符串可以被当作字符列表 &quot;This is a string&quot;[0] # =&gt; &#39;T&#39; # 用.format来格式化字符串 &quot;{} can be {}&quot;.format(&quot;strings&quot;, &quot;interpolated&quot;) # 可以重复参数以节省时间 &quot;{0} be nimble, {0} be quick, {0} jump over the {1}&quot;.format(&quot;Jack&quot;, &quot;candle stick&quot;) #=&gt; &quot;Jack be nimble, Jack be quick, Jack jump over the candle stick&quot; # 如果不想数参数，可以用关键字 &quot;{name} wants to eat {food}&quot;.format(name=&quot;Bob&quot;, food=&quot;lasagna&quot;) #=&gt; &quot;Bob wants to eat lasagna&quot; # 如果你的Python3程序也要在Python2.5以下环境运行，也可以用老式的格式化语法 &quot;%s can be %s the %s way&quot; % (&quot;strings&quot;, &quot;interpolated&quot;, &quot;old&quot;) # None是一个对象 None # =&gt; None # 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。 &quot;etc&quot; is None # =&gt; False None is None # =&gt; True # None，0，空字符串，空列表，空字典都算是False # 所有其他值都是True bool(0) # =&gt; False bool(&quot;&quot;) # =&gt; False bool([]) #=&gt; False bool({}) #=&gt; False #################################################### ## 2. 变量和集合 #################################################### # print是内置的打印函数 print(&quot;I&#39;m Python. Nice to meet you!&quot;) # 在给变量赋值前不用提前声明 # 传统的变量命名是小写，用下划线分隔单词 some_var = 5 some_var # =&gt; 5 # 访问未赋值的变量会抛出异常 # 参考流程控制一段来学习异常处理 some_unknown_var # 抛出NameError # 用列表(list)储存序列 li = [] # 创建列表时也可以同时赋给元素 other_li = [4, 5, 6] # 用append在列表最后追加元素 li.append(1) # li现在是[1] li.append(2) # li现在是[1, 2] li.append(4) # li现在是[1, 2, 4] li.append(3) # li现在是[1, 2, 4, 3] # 用pop从列表尾部删除 li.pop() # =&gt; 3 且li现在是[1, 2, 4] # 把3再放回去 li.append(3) # li变回[1, 2, 4, 3] # 列表存取跟数组一样 li[0] # =&gt; 1 # 取出最后一个元素 li[-1] # =&gt; 3 # 越界存取会造成IndexError li[4] # 抛出IndexError # 列表有切割语法 li[1:3] # =&gt; [2, 4] # 取尾 li[2:] # =&gt; [4, 3] # 取头 li[:3] # =&gt; [1, 2, 4] # 隔一个取一个 li[::2] # =&gt;[1, 4] # 倒排列表 li[::-1] # =&gt; [3, 4, 2, 1] # 可以用三个参数的任何组合来构建切割 # li[始:终:步伐] # 用del删除任何一个元素 del li[2] # li is now [1, 2, 3] # 列表可以相加 # 注意：li和other_li的值都不变 li + other_li # =&gt; [1, 2, 3, 4, 5, 6] # 用extend拼接列表 li.extend(other_li) # li现在是[1, 2, 3, 4, 5, 6] # 用in测试列表是否包含值 1 in li # =&gt; True # 用len取列表长度 len(li) # =&gt; 6 # 元组是不可改变的序列 tup = (1, 2, 3) tup[0] # =&gt; 1 tup[0] = 3 # 抛出TypeError # 列表允许的操作元组大都可以 len(tup) # =&gt; 3 tup + (4, 5, 6) # =&gt; (1, 2, 3, 4, 5, 6) tup[:2] # =&gt; (1, 2) 2 in tup # =&gt; True # 可以把元组合列表解包，赋值给变量 a, b, c = (1, 2, 3) # 现在a是1，b是2，c是3 # 元组周围的括号是可以省略的 d, e, f = 4, 5, 6 # 交换两个变量的值就这么简单 e, d = d, e # 现在d是5，e是4 # 用字典表达映射关系 empty_dict = {} # 初始化的字典 filled_dict = {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} # 用[]取值 filled_dict[&quot;one&quot;] # =&gt; 1 # 用keys获得所有的键。因为keys返回一个可迭代对象，所以在这里把结果包在list里。我们下面会详细介绍可迭代。 # 注意：字典键的顺序是不定的，你得到的结果可能和以下不同。 list(filled_dict.keys()) # =&gt; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;] # 用values获得所有的值。跟keys一样，要用list包起来，顺序也可能不同。 list(filled_dict.values()) # =&gt; [3, 2, 1] # 用in测试一个字典是否包含一个键 &quot;one&quot; in filled_dict # =&gt; True 1 in filled_dict # =&gt; False # 访问不存在的键会导致KeyError filled_dict[&quot;four&quot;] # KeyError # 用get来避免KeyError filled_dict.get(&quot;one&quot;) # =&gt; 1 filled_dict.get(&quot;four&quot;) # =&gt; None # 当键不存在的时候get方法可以返回默认值 filled_dict.get(&quot;one&quot;, 4) # =&gt; 1 filled_dict.get(&quot;four&quot;, 4) # =&gt; 4 # setdefault方法只有当键不存在的时候插入新值 filled_dict.setdefault(&quot;five&quot;, 5) # filled_dict[&quot;five&quot;]设为5 filled_dict.setdefault(&quot;five&quot;, 6) # filled_dict[&quot;five&quot;]还是5 # 字典赋值 filled_dict.update({&quot;four&quot;:4}) #=&gt; {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4} filled_dict[&quot;four&quot;] = 4 # 另一种赋值方法 # 用del删除 del filled_dict[&quot;one&quot;] # 从filled_dict中把one删除 # 用set表达集合 empty_set = set() # 初始化一个集合，语法跟字典相似。 some_set = {1, 1, 2, 2, 3, 4} # some_set现在是{1, 2, 3, 4} # 可以把集合赋值于变量 filled_set = some_set # 为集合添加元素 filled_set_add(5) # filled_set现在是{1, 2, 3, 4, 5} # &amp; 取交集 other_set = {3, 4, 5, 6} filled_set &amp; other_set # =&gt; {3, 4, 5} # | 取并集 filled_set | other_set # =&gt; {1, 2, 3, 4, 5, 6} # - 取补集 {1, 2, 3, 4} - {2, 3, 5} # =&gt; {1, 4} # in 测试集合是否包含元素 2 in filled_set # =&gt; True 10 in filled_set # =&gt; False #################################################### ## 3. 流程控制和迭代器 #################################################### # 先随便定义一个变量 some_var = 5 # 这是一个if语句。注意缩进在Python里是有意义的 # 打印出&quot;some_var比10小&quot; if some_var &gt; 10: print(&quot;some_var比10大&quot;) elif some_var &lt; 10: # elif句是可选的 print(&quot;some_var比10小&quot;) else: # else也是可选的 print(&quot;some_var就是10&quot;) &quot;&quot;&quot; 用for循环语句遍历列表 打印: dog is a mammal cat is a mammal mouse is a mammal &quot;&quot;&quot; for animal in [&quot;dog&quot;, &quot;cat&quot;, &quot;moouse&quot;]: print(&quot;{} is a animal&quot;.format(animal)) &quot;&quot;&quot; &quot;range(number)&quot;返回数字列表从0到给的数字 打印: 0 1 2 3 &quot;&quot;&quot; for i in range(4): print(i) &quot;&quot;&quot; while循环直到条件不满足 打印: 0 1 2 3 &quot;&quot;&quot; x = 0 while x &lt; 4: print(x) x += 1 # x = x + 1 的简写 # 用try/except块处理异常状况 try: # 用raise抛弃异常 raise IndexError(&quot;This is an index error&quot;) except IndexError as e: pass # pass是无操作，但是应该在这里处理错误 except (TypeError, NameError): pass # 可以同时处理不同类的错误 else: # else语句是可选的，必须在所有的except之后 print(&quot;All good!&quot;) # 只有当try运行完没有错误的时候这句才会运行 # Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列 # 的对象。比如说上面range返回的对象就是可迭代的。 filled_dict = {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} our_iterable = filled_dic.keys() print(our_iterable) # =&gt; range(1,10) 是一个实现可迭代接口的对象 # 可迭代对象可以遍历 for i in our_iterable: print(i) # 打印 one, two, three # 但是不可以随机访问 our_iterable[1] # 抛出TypeError # 可迭代对象知道怎么生成迭代器 our_iterable = iter(our_iterable) # 迭代器是一个可以记住遍历的位置的对象 # 用__next__可以取得下一个元素 our_iterable.__next__() #=&gt; &quot;one&quot; # 再一次调用__next__时会记得位置 our_iterator.__next__() #=&gt; &quot;two&quot; our_iterator.__next__() #=&gt; &quot;three&quot; # 当迭代器所有元素都取出后，会抛出StopIteration our_iterator.__next__() # 抛出StopIteration # 可以用list一次取出迭代器所有元素 list(filled_dict.keys()) #=&gt; Returns [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] #################################################### ## 4. 函数 #################################################### # 用def定义新函数 def add(x, y): print(&quot;x is {} and y is {}&quot;.formatm(x, y)) return x + y 用return语句返回 # 调用函数 add(5, 6) # =&gt; 打印出&quot;x is 5 and y is 6&quot;并且返回11 # 也可以用关键字参数来调用函数 add(y=6, x=5) # 关键字参数可以用任何顺序 #我们可以定义一个可变参数函数 def varargs(*args): return args varargs(1, 2, 3) # =&gt; (1, 2, 3) # 我们也可以定义一个关键字可变参数函数 def keyword_args(**kwargs): return kwargs # 看看结果是什么 keyword_args(big=&quot;foot&quot;, loch=&quot;ness&quot;) # =&gt; {&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;} # 这两种可变参数可以混着用 def all_the args(*args, **kwargs): print(args) print(kwargs) &quot;&quot;&quot; all_the_args(1, 2, a=3, b=4) prints: (1, 2) {&quot;a&quot;: 3, &quot;b&quot;: 4} &quot;&quot;&quot; # 调用可变参数函数时可以做跟上面相反的，用*展开序列，用**展开字典。 args = (1, 2, 3, 4) kwargs = {&quot;a&quot;: 3, &quot;b&quot;: 4} all_the_args(*args) # 相当于 foo(1, 2, 3, 4) all_the_args(**kwargs) # 相当于 foo(a=3, b=4) all_the_args(*args, **kwargs) # 相当于 foo(1, 2, 3, 4, a=3, b=4) # 函数作用域 x = 5 def setX(num): # 局部作用域的x和全局作用域的x是不同的 x = num # =&gt; 43 print (x) # =&gt; 43 def setGlobalX(num): global x print (x) # =&gt; 5 x = num #现在全局作用域的x被赋值 print (x) # =&gt; 6 setX(43) setGlobalX(6) # 函数在Python是一等公民 def create_adder(x): def adder(y): return x + y return adder add_10 = create_adder(10) add_10(3) # =&gt; 13 # 也有匿名函数 (lambda x: x &gt; 2)(3) # =&gt; True # 内置的高阶函数 map(add_10, [1, 2, 3]) # =&gt; [11, 12, 13] filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]) # =&gt; [6, 7] #用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。 [add_10(i) for i in [1, 2, 3]] # =&gt; [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7] #################################################### ## 5. 类 #################################################### # 定义一个继承object的类 class Human(object): # 类属性，被所有此类的实例共用。 species = &quot;H. sapiens&quot; # 构造方法，当实例被初始化时调用。注意名字前后的双下划线，这是表名这个属 # 性或方法对Python有特殊意义，但是允许用户自定义。自己取名时不应该用这种格式 def __init__(self, name): # Assign the argument to the instance&#39;s name attribute self.name = name # 实例方法，第一个参数总是self，就是这个实例对象 def say(self, msg): return &quot;{name}: {message}&quot;.format(name=self.name, message=msg) # 类方法，被所有此类的实例共用。第一个参数是这个类对象。 @classmethod def get_species(cls): return cls.species # 静态方法。调用时没有实例或类的绑定。 @staticmethod def grunt(): return &quot;*grunt*&quot; # 构造一个实例 i = Human(name=&quot;Ian&quot;) print(i.say(&quot;hi&quot;)) # 打印出 &quot;Ian: hi&quot; j = Human(&quot;Joel&quot;) print(j.say(&quot;hello&quot;)) # 印出 &quot;Joel: hello&quot; # 调用一个类方法 i.get_species() # =&gt; &quot;H. sapiens&quot; # 改一个共用的类属性 Human.species = &quot;H. neanderthalensis&quot; i.get_species() # =&gt; &quot;H. neanderthalensis&quot; j.get_species() # =&gt; &quot;H. neanderthalensis&quot; # 调用静态方法 Human.grunt() # =&gt; &quot;*grunt*&quot; #################################################### ## 6. 模块 #################################################### # 用import导入模块 import math print(math.sqrt(16)) # =&gt; 4.0 # 也可以从模块中导入个别值 from math import ceil,floor print(ceil(3.7)) # =&gt; 4.0 print(floor(3.7)) # =&gt; 3.0 # 可以导入一个模块中所有值 # 警告：不建议这么做 from math import * # 如此缩写模块名字 import math as m math.sqrt(16) == m.sqrt(16) # =&gt; True # Python模块其实就是普通的Python文件。 # 你可以自己写，然后导入，模块的名字就是文件的名字。 # 你可以这样列出一个模块里所有的值 import math dir(math) #################################################### ## 7. 高级用法 #################################################### # 用生成器(generators)方便的写惰性计算 def double_numbers(iterable): for i in iterable: yield i + i # 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的 # 值全部计算好。这意味着double_numbers不会生成大于15的数字。 # # range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。 # # 如果你想用一个Python的关键字当作变量，可以加一个下划线来区分。 range_ = range(1, 900000000) # 当找到一个 &gt;= 30 的结果就会停 for i in double_numbers(range_): print(i) if i &gt;= 30: break # 装饰器(decorators) # 这个例子中，beg装饰say # beg会先调用say。如果返回的say_please为真，beg会改变返回的字符串。 from functools import wraps def beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return &quot;{} {}&quot;.format(msg, &quot;Please! I am poor :(&quot;) return msg return wrapper @beg def say(say_please=False): msg = &quot;Can you buy me a beer?&quot; return msg, say_please print(say()) # Can you buy me a beer? print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :( }","categories":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lee.js.org/Cat/tags/Python/"}],"keywords":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}]},{"title":"初识Linux","slug":"初识Linux","date":"2018-07-12T08:27:26.000Z","updated":"2019-03-08T04:04:38.881Z","comments":true,"path":"2018/07/12/初识Linux/","link":"","permalink":"https://lee.js.org/Cat/2018/07/12/初识Linux/","excerpt":"初步认识Linux,我们一起来预览一下命令吧！","text":"初步认识Linux,我们一起来预览一下命令吧！ { $ date 显示系统当前时间和日期 $ cal 显示当前月份的日历 $ df 查看磁盘剩余空间的数量 $ free 显示空闲内存的数量 $ exit 结束终端会话 &lt;!--more--&gt; $ pwd 打印出当前工作目录名 $ cd 更改目录 $ ls 列出目录内容 $ file 确定文件类型 $ less 浏览文件内容 $ cp 复制文件和目录 $ mv 移动/重命名文件和目录 $ mkdir 创建目录 $ rm 删除文件和目录 $ ln 创建硬链接和符号链接 $ type 说明怎样解释一个命令名 $ which 显示会执行哪个可执行程序 $ man 显示命令手册页 $ apropos 显示一系列适合的命令 $ info 显示命令 info $ whatis 显示一个命令的简洁描述 $ alias 创建命令别名 $ unalias 删除命令别名 $ cat 连接文件 $ sort 排序文本行 $ uniq 报道或省略重复行 $ grep 打印匹配行 $ wc 打印文件中换行符，字，和字节个数 $ head 输出文件第一部分 $ tail 输出文件最后一部分 $ echo 显示一行文本 $ clear 清空屏幕 $ history 显示历史列表内容 }","categories":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://lee.js.org/Cat/tags/Linux/"}],"keywords":[{"name":"Backend","slug":"Backend","permalink":"https://lee.js.org/Cat/categories/Backend/"}]},{"title":"DOM","slug":"DOM","date":"2018-07-11T06:43:11.000Z","updated":"2019-03-08T04:05:25.707Z","comments":true,"path":"2018/07/11/DOM/","link":"","permalink":"https://lee.js.org/Cat/2018/07/11/DOM/","excerpt":"DOM: Document Object Model（文档对象模型）,DOM 是 W3C（万维网联盟）的标准。“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型","text":"DOM: Document Object Model（文档对象模型）,DOM 是 W3C（万维网联盟）的标准。“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 DOM节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 HTML DOM 节点树（DOM树）HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树： 通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。 HTML DOM 对象 - 方法和属性获取页面元素* document.getElementById(&#39;list&#39;) ---- 返回DOM节点 速度最快 * document.getElementsByTagName(&#39;div) ---- 返回类数组 * document.getElementsByClassName(&#39;list&#39;) ---- 返回类数组 ie8 有兼容性问题 * document.getElementsByName() --- 返回类数组 如：获取表单name属性 * ducument.body ---- 获取body * 通过id 获取不到返回null，其他几项返回 []. DOM对象方法预览 方法 描述 getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 appendChild() 把新的子节点添加到指定节点。 removeChild() 删除子节点。 replaceChild() 替换子节点 insertBefore() 在指定的子节点前面插入新的子节点。 createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 getAttribute() 返回指定的属性值。 setAttribute() 把指定属性设置或修改为指定的值 节点的类型nodetype 节点的属性 节点类型 nodetype 元素节点 1 文本节点 3 属性节点 2 注释节点 8 文档节点 9 节点的属性 nodetype 取值：1,2,3 nodeName 取值元素的标签名 如DIV。 文本：#text nodeValue 获取节点的值 文本 属性 DOM节点的增删查改 创建元素节点 document.createElement(&#39;div&#39;); 创建文本节点 document.creatTextNode(&#39;你好&#39;); 插入节点 var parent=document.getElementById(&quot;div1&quot;); //父元素 1. parent.appendChild() //往后面加 2. parent.insertBefoer(new,node); //通过父级在node节点前面添加新的节点 ps:已经存在页面上的元素，如果使用appendchild,insertBefore操作则会移动这个元素 复制节点 ele.cloneNode(boolean); ele.cloneNode(boolean,true); // true为深复制 删除节点 parent.removeChild(ele); 判断是否存在节点 parent.hasChildNode() //返回布尔值 ps:1.标准浏览器中：换行会解析为一个文本节点（即解析空格）。2.在ie8中会忽略上述问题 节点关系和元素关系 关系 节点关系 元素关系(存在兼容性问题 children无兼容性问题) 父级 parentNode parentElement 子级 childNode children 第一个子级 firstChild firstElementChild 最后个子级 lastChild lastElementChild 前一个兄弟 previousSibling previousElementSibling 后一个兄弟 nextSibling nextElementSibling 文本 – 文本 ele.innerHTML(含标签) 文本 ele.innerText(单纯文字) 文本 ele.outerHTML 文本 ele.outerText 属性节点注意：只有html的标准属性才能直接获取例如：id ,className,title等 设置非标准属性 setAttribute(attr,val) 获取非标准属性 ele.getAttribute(&#39;name&#39;); 判断是否存在某费标准属性 ele.hasAttribute(attr) //返回布尔值 删除属性 ele.removeAttribute(attr) CSS:style属性ps:ele.style设置或改变的是内联样式 获取非内联样式 getComputedStyle(ele); //计算过后 getComputedStyle(ele).fontSize; getComputedStyle(ele).[font-size];//[attr] 获取伪元素样式 getCompuyedStyle(ele,&quot;::before&quot;).color; getCompuyedStyle(ele,&quot;::before&quot;).fontSize; getCompuyedStyle(ele,&quot;::before&quot;).[font-size];//兼容ie8-","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://lee.js.org/Cat/tags/Javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://lee.js.org/Cat/tags/DOM/"}],"keywords":[{"name":"Frontend","slug":"Frontend","permalink":"https://lee.js.org/Cat/categories/Frontend/"}]},{"title":"Hexo使用","slug":"Hexo使用","date":"2018-07-05T07:31:47.000Z","updated":"2019-03-08T04:05:16.370Z","comments":true,"path":"2018/07/05/Hexo使用/","link":"","permalink":"https://lee.js.org/Cat/2018/07/05/Hexo使用/","excerpt":"经过一段时间的折腾终于用 Hexo + GitHub 搭建起了一个个人博客站点，第一时间边学边写，弄出了这第一篇博客，心里甚是欢喜。","text":"经过一段时间的折腾终于用 Hexo + GitHub 搭建起了一个个人博客站点，第一时间边学边写，弄出了这第一篇博客，心里甚是欢喜。 Hexo是一款“快速、简洁且高效的博客框架”，支持 Markdown 的所有功能。所以，写出一篇博客必须学习 Hexo 和 Markdown 的使用规则。 配置文件命名规则和路由地址Hexo 默认以标题作为文件名称，可以通过 Hexo 的配置文件 _config.yml 中的 new_post_name 参数来改变默认的文件名称，例如： new_post_name: :year-:month-:day-:title.md 当创建博客时，就会以这种格式生成Markdown文件，如这篇博客的文件名就生成 2017-01-13-hexo-blog.md 这种形式。其中相关变量说明如下表： 变量 说明 :title 标题（小写，空格将会被替换为短杠） :year 创建的年份，如：2017 :month 创建的月份（有前导零），如：01 :i_month 创建的月份（无前导零），如：1 :day 创建的日期（有前导零），如：09 :i_day 创建的月份（无前导零），如：9 配置浏览器地址栏中的URL。同样在 Hexo 的配置文件 _config.yml 中, 配置 permalink 属性 ，例如： permalink: /blog/:year/:month/:day/:title/ 当在地址栏访问时，就会如下方式呈现出来： http://localhost:4000/blog/2017/01/13/hexo-blog/ 特殊字符在写博客时,一定注意不要写这些字符,如果要写,就进行转义有些人可能说可以使用反斜杠 \\ 来处理,我这里不建议,因为我使用的时候没有解决问题。下面是比较常见的几个: ! &amp;#33; — 惊叹号Exclamation mark ” &amp;#34; &amp;quot; 双引号Quotation mark # &amp;#35; — 数字标志Number sign $ &amp;#36; — 美元标志Dollar sign % &amp;#37; — 百分号Percent sign &amp; &amp;#38; &amp;amp; Ampersand ‘ &amp;#39; — 单引号Apostrophe ( &amp;#40; — 小括号左边部分Left parenthesis ) &amp;#41; — 小括号右边部分Right parenthesis * &amp;#42; — 星号Asterisk + &amp;#43; — 加号Plus sign &lt; &amp;#60; &amp;lt; 小于号Less than = &amp;#61; — 等于符号Equals sign &gt; &amp;#62; &amp;gt; 大于号Greater than ? &amp;#63; — 问号Question mark @ &amp;#64; — Commercial at [ &amp;#91; --- 中括号左边部分Left square bracket \\ &amp;#92; --- 反斜杠Reverse solidus (backslash) ] &amp;#93; — 中括号右边部分Right square bracket { &amp;#123; — 大括号左边部分Left curly brace | &amp;#124; — 竖线Vertical bar } &amp;#125; — 大括号右边部分Right curly brace 特别注意的是小括号 ( ) 大括号 { } ,如果不小心写了,你执行hexo s –debug可能报一些莫名其妙的错误! 创建博客在命令行中用如下命令创建一篇新的文章 $ hexo new [layout] &lt;title&gt; 布局（layout） 存储路径 说明 post source/_posts 默认，可以直接发布 page source 在source下新建一个文件夹 draft source/_drafts 新建文件将保持到_drafts中 可以用 publish 命令将草稿移动到 source/_posts 文件夹下 $ hexo publish [layout] &lt;title&gt; 写作经过上面上面一系列的准备工作，现在差不多就可以安心的写作了。打开 source/_posts 文件夹下刚创建的 Markdown 文件，你会发现有如下内容： --- title: hexo-blog date: 2017-01-13 16:07:32 tags: --- 注意，这里的 title 是可以随便改的，当然了 date 也是可以改，不过没有改的必要；这里要说一下 tags 这个属性，如果需要配置多个有两种方式： tags: [tag1, tag2, tag3] tags: - tag1 - tag2 - tag3 Hexo 是支持 Markdown 的所有功能的，所以，下面去学习一下 Markdown 的语法规范 斜体和粗体写法： *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 效果：斜体文本 斜体文本粗体文本 粗体文本粗斜体文本 粗斜体文本 分级标题写法： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 超链接写法： 行内形式：[我的博客](https://Lee981265.github.io/) 参考形式：[我的博客][1]，有一个很好的平台-[简书][2]. 这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. [yahoo]: http://www.yahoo.com/ [1]:https://Lee981265.github.io/ [2]:http://www.jianshu.com/ 自动链接：我的博客地址&lt;https://Lee981265.github.io/&gt; 效果：行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-[简书][2][1]:https://Lee981265.github.io/[2]:http://www.jianshu.com/自动链接：我的博客地址https://Lee981265.github.io/ 列表无序列表：写法： * 无序列表项1 + 无序列表项2 - 无序列表项3 效果： 无序列表项1 无序列表项2 无序列表项3 有序列表写法： 1. 有序列表项1 2. 有序列表项2 3. 有序列表项3 效果 有序列表项1 有序列表项2 有序列表项3 列表嵌套1. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格 2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格 列出所有元素： 无序列表元素 A 元素 A 的有序子列表 前面加四个空格 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 列表里引用： 前面空一行仍然需要在 &gt; 前面加四个空格 引用 普通引用&gt; 引用文本前使用 [大于号+空格] &gt; 折行可以不加，新起一行都要加上哦 引用里嵌套引用&gt; 最外层引用 &gt; &gt; 多一个 &gt; 嵌套一层引用 &gt; &gt; &gt; 可以嵌套很多层 引用里嵌套列表&gt; - 这是引用里嵌套的一个列表 &gt; - 还可以有子列表 &gt; * 子列表需要从 - 之后延后四个空格开始 插入图片在 Hexo 中插入图片，首先需要将图片放在 source/img/ 文件夹下，然后如下方式进行插入 ![这是图片说明](/img/Leebolg.png) 这个链接用 1 作为网址变量 [ Google] [ 1]. 然后在文档的结尾位变量赋值(网址) [1]: http: //www.google.com/logo.png 也可以使用 HTML 的图片语法来自定义图片的宽高大小 &lt;img src=&quot;https://lee981265.github.io/img/Leebolg.png&quot; width=&quot;240&quot; height=&quot;275&quot;&gt; 效果图如下： 换行如果另起一行，只需在当前行结尾加 2 个空格 在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 前面的段落 --- 后面的段落 小型文本Markdown语法： &lt;small&gt;文本内容&lt;/small&gt; 预览效果：我是正常文字我是小型文字 注释用html的注释，好像只有这样？ &lt;!-- 注释 --&gt; 表格| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | | 表头1|表头2|表头3|表头4 |-| :- | :-: | -: | |默认左对齐|左对齐|居中对其|右对齐| |默认左对齐|左对齐|居中对其|右对齐| |默认左对齐|左对齐|居中对其|右对齐| | 参数 | 说明 | 默认值 | | ------------- |:-------------------:|:------------------:| | host | 远程主机的地址 | | | user | 使用者名称 | | | root | 远程主机的根目录 | | | port | 端口 | 22 | | delete | 删除远程主机上的旧文件 | true | | verbose | 显示调试信息 | true | | ignore_errors | 忽略错误 | false | 效果： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 参数 说明 默认值 host 远程主机的地址 user 使用者名称 root 远程主机的根目录 port 端口 22 delete 删除远程主机上的旧文件 true verbose 显示调试信息 true ignore_errors 忽略错误 false 总结记录了一下 Hexo 写博客的环境配置，了解创建博客的过程和一些相关的变量，然后学习一下 Markdown 的基本语法规范，下次有时间在将 Markdown 更深入的使用方法记录一下。","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lee.js.org/Cat/tags/Hexo/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}]},{"title":"Git进阶","slug":"Git进阶","date":"2018-07-05T03:56:25.000Z","updated":"2019-03-08T04:05:21.966Z","comments":true,"path":"2018/07/05/Git进阶/","link":"","permalink":"https://lee.js.org/Cat/2018/07/05/Git进阶/","excerpt":"Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。","text":"Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 与 SVN 区别 GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别点： 1、GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 2、GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 3、GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 4、GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 5、GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git命令我们先来预览一下Git命令{ mkdir： XX (创建一个空目录 XX指目录名) pwd： 显示当前目录的路径。 git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。 git add XX 把xx文件添加到暂存区去。 git reset --mixed 把上次add文件撤销但修改保留。 git commit –m “XX” 提交文件 –m 后面的是注释。 git status 查看仓库状态 git diff XX 查看XX文件修改了那些内容 git log 查看历史记录 git reset –-hard HEAD^ 或者 git reset –-hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –-hard HEAD~100 ) cat XX 查看XX文件内容 git reflog 查看历史记录的版本号id git checkout — XX 把XX文件在工作区的修改全部撤销。 git rm XX 删除XX文件 git rm * 删除所有文件 git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库 git clone https://github.com/tugenhua0707/testgit 从远程库中克隆 git checkout –b dev 创建dev分支 并切换到dev分支上 git branch 查看当前所有的分支 git checkout master 切换回master分支 git merge dev 在当前的分支上合并dev分支 git branch –d dev 删除dev分支 git branch name 创建分支 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时 也删除文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git push origin master Git会把master分支推送到远程库对应的远程分支上 } Git深度理解{ 1.git进入vim界面 输入Ctrl+Z 即可退出 ////////Esc Shift+: 2.查看git所有已配置项 $ git config --list 3.Git撤销commit的操作命令 git reset --hard HEAD^ git reset --hard commitID git reset --hard HEAD@{n} 4.git 撤销初始化 删除 .git 文件即可 或者执行命令 rm -rf .git 5.git add . 出现以下报错 ---------- warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX. ---解决方案：执行命令git config core.autocrlf false 6. 查看git本机 用户名： $ git config --global user.name 邮箱： $ git config --global user.email 更改本机配置 用户名： $ git config --global user.name &quot;Lee&quot; 邮箱： $ git config --global user.email &quot;Jack2244057555@gmail.com&quot; } { 一.Git命令解析 1、git基本命令 1）git add 将想要快照的内容写入缓存区 2）git status -s &quot;AM&quot; 状态的意思是，这个文件在我们将它添加到缓存之后又有改动 3）git commit -m &#39;第一次版本提交&#39; -m选项添加备注信息 4）git clone url 使用 git clone 拷贝一个 Git 仓库到本地 5）git diff 查看执行 git status 的结果的详细信息 尚未缓存的改动：git diff 查看已缓存的改动： git diff --cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff --stat 6）git commit -a 跳过git add 提交缓存的流程 7）git reset HEAD 用于取消已缓存的内容 8）git rm file git rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。 &quot;取消缓存&quot;的意思就是将缓存区恢复为我们做出修改之前的样子。 默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 9）git mv 重命名磁盘上的文件 如 git mv README README.md 10）git push -u origin master 提交代码 2、git 分支管理 1）创建分支命令 git branch (branchname) 列出分支 git branch 2）切换分支命令 git checkout (branchname) 3）合并分支 git merge (branchname) 4）创建新分支并立即切换到该分支下 git checkout -b (branchname) 5）删除分支命令 git branch -d (branchname) ps:状态 uu 表示冲突未解决 可以用 git add 要告诉 Git 文件冲突已经解决 3、查看日志版本 git log 命令列出历史提交记录 git log --oneline 查看历史记录的简洁的版本 git log --oneline --graph 查看历史中什么时候出现了分支、合并 4、标签 为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签： git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID： git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性 5、提取远程仓库代码 1）git fetch 从远程仓库下载新分支与数据 2)）git pull 从远端仓库提取数据并尝试合并到当前分支 6、git分支 git-flow主要有5中分支：master、hotfix、release、develop、feature feature分支开始于develop分支，完成以后合并到develop分支。 当完成一定数量feature分支以后，从develop再开一个release分支出来，这些特性将被更行到下一个发布的版本中， 之后的feature将不会被合并到release中。 之后在release分支中，只修改bug，然后完成release分支。完成release分支会完成以下三个操作： 1、合并release分支到master； 2、给master打上版本的标签 3、release回归到develop分支。 当发现master上有bug时，开一个hotfix，完成后合并到master分支。 初次安装git配置用户名和邮箱 初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： $ git config --global user.name &quot;superGG1990&quot; $ git config --global user.email &quot;superGG1990@163.com&quot; 注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱 git使用ssh密钥 git支持https和git两种传输协议，github分享链接时会有两种协议可选： git协议链接图例 : ↓ https协议链接图例：↓ git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦 初次使用git的用户要使用git协议大概需要三个步骤： 一、生成密钥对 二、设置远程仓库（本文以github为例）上的公钥 三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤） 一、生成密钥对 大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。 SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看： $ cd ~/.ssh $ ls authorized_keys2 id_dsa known_hosts config id_dsa.pub 看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。 假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里： $ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; Creates a new ssh key using the provided email # Generating public/private rsa key pair. Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)： Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样： Your public key has been saved in /home/you/.ssh/id_rsa.pub. The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 到此为止，你本地的密钥对就生成了。 二、添加公钥到你的远程仓库（github） 1、查看你生成的公钥： $ cat ~/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC 2、登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key 3、然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 4、点击 Add key。 完成以后，验证下这个key是不是正常工作： $ ssh -T git@github.com Attempts to ssh to github 如果，看到： Hi xxx! You&#39;ve successfully authenticated, but GitHub does not # provide shell access. 恭喜你，你的设置已经成功了。 三、修改git的remote url 使用命令 git remote -v 查看你当前的 remote url $ git remote -v origin https://github.com/someaccount/someproject.git (fetch) origin https://github.com/someaccount/someproject.git (push) 如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议） 你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url，类似： 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。 git remote set-url origin git@github.com:someaccount/someproject.git 然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了 }","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lee.js.org/Cat/tags/Git/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}]},{"title":"前言","slug":"preface ","date":"2018-07-03T07:32:00.000Z","updated":"2019-03-08T04:05:10.884Z","comments":true,"path":"2018/07/03/preface /","link":"","permalink":"https://lee.js.org/Cat/2018/07/03/preface /","excerpt":"这是我首次使用hexojs编写博客","text":"这是我首次使用hexojs编写博客那么我就来试一试更多内容的相关功能吧！","categories":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}],"tags":[{"name":"ABC","slug":"ABC","permalink":"https://lee.js.org/Cat/tags/ABC/"},{"name":"CBA","slug":"CBA","permalink":"https://lee.js.org/Cat/tags/CBA/"}],"keywords":[{"name":"Essay","slug":"Essay","permalink":"https://lee.js.org/Cat/categories/Essay/"}]}]}